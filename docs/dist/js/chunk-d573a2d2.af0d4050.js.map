{"version":3,"sources":["webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/object.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/OperatorNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/parse.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/function/algebra/simplify/simplifyConstant.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/compile.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/type/matrix/Range.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/bignumber/formatter.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/type/matrix/function/matrix.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/IndexNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/function/algebra/simplify.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/bignumber/isBigNumber.js","webpack:///./node_modules/mathjs-simple-integral/lib/index.js","webpack:///./node_modules/mathjs-simple-integral/index.js","webpack:///./node_modules/mathjs-simple-integral/lib/integral.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/FunctionAssignmentNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/error/ArgumentsError.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/utils/access.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/ArrayNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/type/resultset/ResultSet.js","webpack:///./node_modules/escape-latex/dist/index.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/RangeNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/collection/deepMap.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/operators.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/number.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/AssignmentNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/types.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/string.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/function/algebra/simplify/util.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/customs.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/function/algebra/simplify/simplifyCore.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/utils/getUniqueArgumentName.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/FunctionNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/ObjectNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/BlockNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/AccessorNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/error/DimensionError.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/latex.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/function/matrix/subset.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/utils/array.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/ConditionalNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/transform/error.transform.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/ParenthesisNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/ConstantNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/keywords.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/utils/assign.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/SymbolNode.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/function/algebra/simplify/resolve.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/error/IndexError.js","webpack:///./node_modules/mathjs-simple-integral/node_modules/mathjs/lib/expression/node/Node.js"],"names":["isBigNumber","exports","clone","x","type","undefined","Array","isArray","map","value","Number","valueOf","String","Boolean","Date","RegExp","TypeError","object","callback","key","hasOwnProperty","extend","a","b","prop","deepExtend","constructor","Object","deepEqual","i","len","length","canDefineProperty","defineProperty","get","e","lazy","fn","_value","_uninitialized","set","configurable","enumerable","traverse","path","obj","names","split","name","property","call","isFactory","factory","latex","join","stringify","escape","isSafeMethod","operators","config","load","typed","register","compile","Node","OperatorNode","op","args","implicit","this","SyntaxError","every","isNode","compileOperatorNode","node","defs","math","Error","jsArgs","arg","calculateNecessaryParentheses","root","parenthesis","precedence","getPrecedence","associativity","getAssociativity","getIdentifier","parens","getContent","result","operandPrecedence","operandIdentifier","rootIdentifier","properties","latexLeftParens","latexParens","lhsParens","rhsParens","lhsPrecedence","assocWithLhs","isAssociativeWith","lhsIdentifier","rhsIdentifier","rhsPrecedence","assocWithRhs","latexRightParens","argPrecedence","assocWithArg","argAssociativity","index","isParenthesisNode","prototype","isOperatorNode","forEach","_ifNode","slice","_toString","options","assoc","operand","toString","lhs","rhs","stringifiedArgs","toHTML","_toTex","toTex","lhsTex","rhsTex","texifiedArgs","ArgumentsError","deepMap","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","IndexNode","ObjectNode","ParenthesisNode","FunctionNode","RangeNode","SymbolNode","parse","expr","arguments","extra_nodes","nodes","expression","parseStart","Matrix","elem","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS","'","NAMED_DELIMITERS","comment","c","token","token_type","nesting_level","conditional_level","first","charAt","next","prevPreview","nextPreview","nextNextPreview","getToken","isWhitespace","c2","c3","isDigitDot","isDigit","isDecimalMark","createSyntaxError","isAlpha","getTokenSkipNewline","openParams","closeParams","parseBlock","createError","visible","blocks","parseAssignment","push","valid","parseConditional","isSymbolNode","isAccessorNode","isFunctionNode","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseLogicalXor","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","parseConversion","parseRange","parseAddSubtract","parseMultiplyDivide","last","parseUnary","isConstantNode","parsePow","parseLeftHandOperators","parseCustomNodes","parseAccessors","CustomNode","parseSymbol","parseString","types","indexOf","dotNotation","str","parseStringToken","parseMatrix","array","rows","cols","row","parseRow","items","r","parseObject","parseNumber","number","parseParentheses","parseEnd","col","message","error","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low","nestingLevel","digits","util","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","res","foldFraction","_toNode","_eval","fnname","_toNumber","apply","ignore","isFraction","_fractionToNode","n","unaryMinusNode","negated","s","_exactFraction","isFinite","f","fraction","bignumber","parseFloat","im","re","vn","d","foldOp","makeNode","reduce","ignoreandcontinue","valueType","rawArgs","operatorFunctions","some","ignoreandcontine","consts","vars","unshift","content","compileFunctions","compileFunction","_compile","Range","start","end","step","toNumber","isRange","nums","invalid","num","isNaN","size","diff","sign","Math","ceil","min","max","toArray","format","toJSON","mathjs","fromJSON","json","gt","notation","precision","toFixed","toExponential","lower","upper","exponential","toExpNeg","toExpPos","round","log","LN10","isZero","abs","gte","lt","toSignificantDigits","replace","matrix","_create","datatype","data","storage","0","1","2","M","dimensions","isObjectProperty","deprecated","compileIndexNode","childArgs","create","range","isRangeNode","needsEnd","isIndexNode","getObjectProperty","needsSize","simplifyCore","resolve","flatten","unflattenr","unflattenl","simplify","rules","scope","_buildRules","visited","removeParens","_lastsym","applyRule","transform","parent","SUPPORTED_CONSTANTS","true","false","Infinity","LN2","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","ruleSet","newRule","rule","ruleType","lr","l","context","evaluate","expandsym","_getExpandPlaceholderSymbol","expanded","commutative","repl","matches","_ruleMatch","_transform","placeholders","getSplits","right","rightArgs","splice","mergeMatch","match1","match2","_exactMatch","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","uniqueSets","unique","JSON","isSplit","splits","splitMatches","matchSet","concat","childMatch","substring","p","q","module","integral","variable","debugPrint","IntegrationContext","simplifiedExpr","preprocessIntegrand","integralResult","_integral","cloneDeep","_constantExpr","subIntegral","debugIndent","removeParenthesis","reduceFunctions","removeDivision","helper","isConstant","funcName","getNumericValue","simplified","lastRuleComment","exprString","handler","debugComment","printDebug","isConstantHelper","self","bind","text","indent","console","equals","int","childInts","factors","getFactors","constantFactors","nonConstantFactors","constantNode","factorsToNode","nonConstantNode","nonConstantIntegral","exponentValue","argsAsPower","getExprInPowerForm","reducedArgs","acc","exprPower","base","power","reducedExpr","powerFactorsToNode","powerToNode","powerExpr","exponent","baseChild","wasChange","isTotalPositive","processedArgs","sumNode","otherFactors","filter","newTerms","term","createIntegralWrapper","uniqueParent","getParentOfUniqueVariable","replaceNodeInTree","preIntegral","backSubstituted","replacement","replaceHelper","curNode","nonConstantChildren","child","MaxExponentExpanded","multipliedOut","tryMultiplyOut","multipliedOutChild","isInteger","keywords","setSafeProperty","getUniqueArgumentName","param","compileFunctionAssignmentNode","jsParams","jsExpr","jsName","needParenthesis","exprPrecedence","isFunctionAssignmentNode","toSymbol","count","stack","isArgumentsError","errorTransform","getSafeProperty","subset","err","compileArrayNode","asMatrix","item","isArrayNode","childNode","ResultSet","entries","isResultSet","_extends","assign","target","source","defaultEscapes","$","_","formatEscapes","defaultEscapeMapFn","_ref","_ref$preserveFormatti","preserveFormatting","_ref$escapeMapFn","escapeMapFn","runningStr","escapes","escapeKeys","keys","_loop","specialCharFound","compileRangeNode","startPrecedence","stepPrecedence","endPrecedence","endSymbols","skipZeros","associativeWith","_node","identifier","nodeA","nodeB","identifierA","identifierB","zeros","arr","isNumber","toEngineering","toPrecision","splitNumber","match","toLowerCase","dot","coefficients","parseInt","rounded","roundDigits","newExp","significandsDiff","expDiff","decimalIdx","decimals","decimalVal","splitValue","pp","shift","pow","removed","pop","DBL_EPSILON","EPSILON","nearlyEqual","y","epsilon","access","compileAssignmentNode","jsProp","parentObject","jsParentProperty","parentSize","parentIndex","isAssignmentNode","formatNumber","formatBigNumber","formatArray","looksLikeFraction","isString","endsWith","search","syntax","escaped","associative","children","findChildren","curnode","isPlainObject","isSafeProperty","safeNativeProperties","Function","validateSafeMethod","method","__proto__","safeNativeMethods","toLocaleString","node0","node1","a0","a1","a00","a00_a1","a01","compileFunctionNode","argsName","jsFn","jsScope","compileScope","isRaw","jsObject","nodeToString","expandTemplate","template","regex","inputPos","exec","ReferenceError","customString","nodeToTex","customTex","latexConverter","customToTex","defaultTemplate","compileObjectNode","stringifiedKey","parsedKey","isObjectNode","block","compileBlockNode","js","isBlockNode","compileAccessorNode","DimensionError","actual","expected","relation","RangeError","isDimensionError","escape_latex","symbols","Alpha","alpha","Beta","beta","Gamma","gamma","Delta","delta","Epsilon","varepsilon","Zeta","zeta","Eta","eta","Theta","theta","vartheta","Iota","iota","Kappa","kappa","varkappa","Lambda","lambda","Mu","mu","Nu","nu","Xi","xi","Omicron","omicron","Pi","varpi","Rho","rho","varrho","Sigma","sigma","varsigma","Tau","Upsilon","upsilon","Phi","varphi","Chi","chi","Psi","psi","Omega","omega","inf","Inf","infinity","oo","lim","units","deg","string","isUnit","validateIndex","m","isScalar","_getObjectProperty","_getSubstring","defaultValue","_setSubstring","_setObjectProperty","isIndex","strLen","dimension","substr","v","chars","updated","IndexError","_validate","dim","dimNext","_resize","oldLen","newLen","minLen","UNINITIALIZED","_reshape","sizes","accumulator","_squeeze","dims","ii","_unsqueeze","validate","resize","_defaultValue","reshape","newArray","flatArray","product","curr","squeeze","unsqueeze","outer","flat","filterRegExp","regexp","entry","separator","identify","generalize","compileConditionalNode","testCondition","isComplex","isConditionalNode","conditionPrecedence","truePrecedence","falsePrecedence","isIndexError","compileParenthesisNode","getType","escapeLatex","SUPPORTED_TYPES","compileConstantNode","validateNumericValue","isValuelessUnit","Unit","compileSymbolNode","undef","symbol","_validateScope","eval","mathWithTransform","code","defsCode","factoryCode","_traverse","find","other"],"mappings":"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","file":"js/chunk-d573a2d2.af0d4050.js","sourcesContent":["'use strict';\n\nvar isBigNumber = require('./bignumber/isBigNumber');\n\n/**\n * Clone an object\n *\n *     clone(x)\n *\n * Can clone any primitive type, array, and object.\n * If x has a function clone, this function will be invoked to clone the object.\n *\n * @param {*} x\n * @return {*} clone\n */\nexports.clone = function clone(x) {\n  var type = typeof x;\n\n  // immutable primitive types\n  if (type === 'number' || type === 'string' || type === 'boolean' ||\n      x === null || x === undefined) {\n    return x;\n  }\n\n  // use clone function of the object when available\n  if (typeof x.clone === 'function') {\n    return x.clone();\n  }\n\n  // array\n  if (Array.isArray(x)) {\n    return x.map(function (value) {\n      return clone(value);\n    });\n  }\n\n  if (x instanceof Number)    return new Number(x.valueOf());\n  if (x instanceof String)    return new String(x.valueOf());\n  if (x instanceof Boolean)   return new Boolean(x.valueOf());\n  if (x instanceof Date)      return new Date(x.valueOf());\n  if (isBigNumber(x))         return x; // bignumbers are immutable\n  if (x instanceof RegExp)  throw new TypeError('Cannot clone ' + x);  // TODO: clone a RegExp\n\n  // object\n  return exports.map(x, clone);\n};\n\n/**\n * Apply map to all properties of an object\n * @param {Object} object\n * @param {function} callback\n * @return {Object} Returns a copy of the object with mapped properties\n */\nexports.map = function(object, callback) {\n  var clone = {};\n\n  for (var key in object) {\n    if (exports.hasOwnProperty(object, key)) {\n      clone[key] = callback(object[key]);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Extend object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\nexports.extend = function(a, b) {\n  for (var prop in b) {\n    if (exports.hasOwnProperty(b, prop)) {\n      a[prop] = b[prop];\n    }\n  }\n  return a;\n};\n\n/**\n * Deep extend an object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @returns {Object}\n */\nexports.deepExtend = function deepExtend (a, b) {\n  // TODO: add support for Arrays to deepExtend\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var prop in b) {\n    if (exports.hasOwnProperty(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop]);\n        }\n        else {\n          a[prop] = b[prop];\n        }\n      } else if (Array.isArray(b[prop])) {\n        throw new TypeError('Arrays are not supported by deepExtend');\n      } else {\n        a[prop] = b[prop];\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * Deep test equality of all fields in two pairs of arrays or objects.\n * @param {Array | Object} a\n * @param {Array | Object} b\n * @returns {boolean}\n */\nexports.deepEqual = function deepEqual (a, b) {\n  var prop, i, len;\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n\n    if (a.length != b.length) {\n      return false;\n    }\n\n    for (i = 0, len = a.length; i < len; i++) {\n      if (!exports.deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  else if (a instanceof Object) {\n    if (Array.isArray(b) || !(b instanceof Object)) {\n      return false;\n    }\n\n    for (prop in a) {\n      //noinspection JSUnfilteredForInLoop\n      if (!exports.deepEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n    for (prop in b) {\n      //noinspection JSUnfilteredForInLoop\n      if (!exports.deepEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  else {\n    return (typeof a === typeof b) && (a == b);\n  }\n};\n\n/**\n * Test whether the current JavaScript engine supports Object.defineProperty\n * @returns {boolean} returns true if supported\n */\nexports.canDefineProperty = function () {\n  // test needed for broken IE8 implementation\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty({}, 'x', { get: function () {} });\n      return true;\n    }\n  } catch (e) {}\n\n  return false;\n};\n\n/**\n * Attach a lazy loading property to a constant.\n * The given function `fn` is called once when the property is first requested.\n * On older browsers (<IE8), the function will fall back to direct evaluation\n * of the properties value.\n * @param {Object} object   Object where to add the property\n * @param {string} prop     Property name\n * @param {Function} fn     Function returning the property value. Called\n *                          without arguments.\n */\nexports.lazy = function (object, prop, fn) {\n  if (exports.canDefineProperty()) {\n    var _uninitialized = true;\n    var _value;\n    Object.defineProperty(object, prop, {\n      get: function () {\n        if (_uninitialized) {\n          _value = fn();\n          _uninitialized = false;\n        }\n        return _value;\n      },\n\n      set: function (value) {\n        _value = value;\n        _uninitialized = false;\n      },\n\n      configurable: true,\n      enumerable: true\n    });\n  }\n  else {\n    // fall back to immediate evaluation\n    object[prop] = fn();\n  }\n};\n\n/**\n * Traverse a path into an object.\n * When a namespace is missing, it will be created\n * @param {Object} object\n * @param {string} path   A dot separated string like 'name.space'\n * @return {Object} Returns the object at the end of the path\n */\nexports.traverse = function(object, path) {\n  var obj = object;\n\n  if (path) {\n    var names = path.split('.');\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (!(name in obj)) {\n        obj[name] = {};\n      }\n      obj = obj[name];\n    }\n  }\n\n  return obj;\n};\n\n/**\n * A safe hasOwnProperty\n * @param {Object} object\n * @param {string} property\n */\nexports.hasOwnProperty = function (object, property) {\n  return object && Object.hasOwnProperty.call(object, property);\n}\n\n/**\n * Test whether an object is a factory. a factory has fields:\n *\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\n * - name: string (optional)\n * - path: string    A dot separated path (optional)\n * - math: boolean   If true (false by default), the math namespace is passed\n *                   as fifth argument of the factory function\n *\n * @param {*} object\n * @returns {boolean}\n */\nexports.isFactory = function (object) {\n  return object && typeof object.factory === 'function';\n};\n","'use strict';\n\nvar latex = require('../../utils/latex');\nvar map = require('../../utils/array').map;\nvar join = require('../../utils/array').join;\nvar stringify = require('../../utils/string').stringify;\nvar escape = require('../../utils/string').escape;\nvar isSafeMethod = require('../../utils/customs').isSafeMethod;\nvar operators = require('../operators');\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node         = load(require('./Node'));\n  var ConstantNode = load(require('./ConstantNode'));\n  var SymbolNode   = load(require('./SymbolNode'));\n  var FunctionNode = load(require('./FunctionNode'));\n\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    //validate input\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n    if (!Array.isArray(args) || !args.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = (implicit === true);\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n\n  OperatorNode.prototype.type = 'OperatorNode';\n\n  OperatorNode.prototype.isOperatorNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {OperatorNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileOperatorNode(node, defs, args) {\n    if (!(node instanceof OperatorNode)) {\n      throw new TypeError('No valid OperatorNode')\n    }\n\n    // validate fn\n    if (typeof node.fn !== 'string' || !isSafeMethod(defs.math, node.fn)) {\n      if (!defs.math[node.fn]) {\n        throw new Error('Function ' + node.fn + ' missing in provided namespace \"math\"');\n      }\n      else {\n        throw new Error('No access to function \"' + node.fn + '\"');\n      }\n    }\n\n    var jsArgs = map(node.args, function (arg) {\n      return compile(arg, defs, args);\n    });\n\n    return 'math[' + stringify(node.fn) + '](' + join(jsArgs, ', ') + ')';\n  }\n\n  // register the compile function\n  register(OperatorNode.prototype.type, compileOperatorNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    //precedence of the root OperatorNode\n    var precedence = operators.getPrecedence(root, parenthesis);\n    var associativity = operators.getAssociativity(root, parenthesis);\n\n    if ((parenthesis === 'all') || ((args.length > 2) && (root.getIdentifier() !== 'OperatorNode:add') && (root.getIdentifier() !== 'OperatorNode:multiply'))) {\n      var parens = args.map(function (arg) {\n        switch (arg.getContent().type) { //Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n            break;\n          default:\n            return true;\n        }\n      });\n      return parens;\n    }\n\n    var result = undefined;\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1: //unary operators\n        //precedence of the operand\n        var operandPrecedence = operators.getPrecedence(args[0], parenthesis);\n\n        //handle special cases for LaTeX, where some of the parentheses aren't needed\n        if (latex && (operandPrecedence !== null)) {\n          var operandIdentifier;\n          var rootIdentifier;\n          if (parenthesis === 'keep') {\n            operandIdentifier = args[0].getIdentifier();\n            rootIdentifier = root.getIdentifier();\n          }\n          else {\n            //Ignore Parenthesis Nodes when not in 'keep' mode\n            operandIdentifier = args[0].getContent().getIdentifier();\n            rootIdentifier = root.getContent().getIdentifier();\n          }\n          if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n            result = [false];\n            break;\n          }\n\n          if (operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n            result = [false];\n            break;\n          }\n        }\n\n        if (operandPrecedence === null) {\n          //if the operand has no defined precedence, no parens are needed\n          result = [false];\n          break;\n        }\n\n        if (operandPrecedence <= precedence) {\n          //if the operands precedence is lower, parens are needed\n          result = [true];\n          break;\n        }\n\n        //otherwise, no parens needed\n        result = [false];\n        break;\n\n      case 2: //binary operators\n        var lhsParens; //left hand side needs parenthesis?\n        //precedence of the left hand side\n        var lhsPrecedence = operators.getPrecedence(args[0], parenthesis);\n        //is the root node associative with the left hand side\n        var assocWithLhs = operators.isAssociativeWith(root, args[0], parenthesis);\n\n        if (lhsPrecedence === null) {\n          //if the left hand side has no defined precedence, no parens are needed\n          //FunctionNode for example\n          lhsParens = false;\n        }\n        else if ((lhsPrecedence === precedence) && (associativity === 'right') && !assocWithLhs) {\n          //In case of equal precedence, if the root node is left associative\n          // parens are **never** necessary for the left hand side.\n          //If it is right associative however, parens are necessary\n          //if the root node isn't associative with the left hand side\n          lhsParens = true;\n        }\n        else if (lhsPrecedence < precedence) {\n          lhsParens = true;\n        }\n        else {\n          lhsParens = false;\n        }\n\n        var rhsParens; //right hand side needs parenthesis?\n        //precedence of the right hand side\n        var rhsPrecedence = operators.getPrecedence(args[1], parenthesis);\n        //is the root node associative with the right hand side?\n        var assocWithRhs = operators.isAssociativeWith(root, args[1], parenthesis);\n\n        if (rhsPrecedence === null) {\n          //if the right hand side has no defined precedence, no parens are needed\n          //FunctionNode for example\n          rhsParens = false;\n        }\n        else if ((rhsPrecedence === precedence) && (associativity === 'left') && !assocWithRhs) {\n          //In case of equal precedence, if the root node is right associative\n          // parens are **never** necessary for the right hand side.\n          //If it is left associative however, parens are necessary\n          //if the root node isn't associative with the right hand side\n          rhsParens = true;\n        }\n        else if (rhsPrecedence < precedence) {\n          rhsParens = true;\n        }\n        else {\n          rhsParens = false;\n        }\n\n        //handle special cases for LaTeX, where some of the parentheses aren't needed\n        if (latex) {\n          var rootIdentifier;\n          var lhsIdentifier;\n          var rhsIdentifier;\n          if (parenthesis === 'keep') {\n            rootIdentifier = root.getIdentifier();\n            lhsIdentifier = root.args[0].getIdentifier();\n            rhsIdentifier = root.args[1].getIdentifier();\n          }\n          else {\n            //Ignore ParenthesisNodes when not in 'keep' mode\n            rootIdentifier = root.getContent().getIdentifier();\n            lhsIdentifier = root.args[0].getContent().getIdentifier();\n            rhsIdentifier = root.args[1].getContent().getIdentifier();\n          }\n\n          if (lhsPrecedence !== null) {\n            if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              lhsParens = false;\n            }\n\n            if (operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n              lhsParens = false;\n            }\n          }\n\n          if (rhsPrecedence !== null) {\n            if (operators.properties[precedence][rootIdentifier].latexRightParens === false) {\n              rhsParens = false;\n            }\n\n            if (operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n              rhsParens = false;\n            }\n          }\n        }\n\n        result = [lhsParens, rhsParens];\n        break;\n\n      default:\n        if ((root.getIdentifier() === 'OperatorNode:add') || (root.getIdentifier() === 'OperatorNode:multiply')) {\n          var result = args.map(function (arg) {\n            var argPrecedence = operators.getPrecedence(arg, parenthesis);\n            var assocWithArg = operators.isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = operators.getAssociativity(arg, parenthesis);\n            if (argPrecedence === null) {\n              //if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if ((precedence === argPrecedence) && (associativity === argAssociativity) && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n        break;\n    }\n\n    //handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    //In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    //printed.\n    if ((args.length >= 2) && (root.getIdentifier() === 'OperatorNode:multiply') && root.implicit && (parenthesis === 'auto') && (implicit === 'hide')) {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = (arg.getIdentifier() === 'ParenthesisNode');\n        if (result[index] || isParenthesisNode) { //put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var implicit = (options && options.implicit) ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) { //unary operators\n      var assoc = operators.getAssociativity(this, parenthesis);\n\n      var operand = args[0].toString(options);\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      }\n\n      if (assoc === 'right') { //prefix operator\n        return this.op + operand;\n      }\n      else if (assoc === 'left') { //postfix\n        return operand + this.op;\n      }\n\n      //fall back to postfix\n      return operand + this.op;\n    } else if (args.length == 2) {\n      var lhs = args[0].toString(options); //left hand side\n      var rhs = args[1].toString(options); //right hand side\n      if (parens[0]) { //left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n      if (parens[1]) { //right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit == 'hide')) {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if ((args.length > 2) && ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply'))) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n        if (parens[index]) { //put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit === 'hide')) {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      //fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var implicit = (options && options.implicit) ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) { //unary operators\n      var assoc = operators.getAssociativity(this, parenthesis);\n\n      var operand = args[0].toHTML(options);\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') { //prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n      }\n      else if (assoc === 'left') { //postfix\n        return '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n      }\n\n      //fall back to postfix\n      return '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n    }\n\telse if (args.length == 2) { // binary operatoes\n      var lhs = args[0].toHTML(options); //left hand side\n      var rhs = args[1].toHTML(options); //right hand side\n      if (parens[0]) { //left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      if (parens[1]) { //right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\t  \n\t  if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit == 'hide')) {\n\t    return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n\t  }\n      \n\t  return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n    }\n\telse if ((args.length > 2) && ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply'))) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n        if (parens[index]) { //put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit === 'hide')) {\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n      }\n\n      return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n    } else {\n      //fallback to formatting as a function call\n      return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n    }\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var implicit = (options && options.implicit) ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = latex.operators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; //fall back to using this.op\n\n    if (args.length === 1) { //unary operators\n      var assoc = operators.getAssociativity(this, parenthesis);\n\n      var operand = args[0].toTex(options);\n      if (parens[0]) {\n        operand = '\\\\left(' + operand + '\\\\right)';\n      }\n\n      if (assoc === 'right') { //prefix operator\n        return op + operand;\n      }\n      else if (assoc === 'left') { //postfix operator\n        return operand + op;\n      }\n\n      //fall back to postfix\n      return operand + op;\n    } else if (args.length === 2) { //binary operators\n      var lhs = args[0]; //left hand side\n      var lhsTex = lhs.toTex(options);\n      if (parens[0]) {\n        lhsTex = '\\\\left(' + lhsTex + '\\\\right)';\n      }\n\n      var rhs = args[1]; //right hand side\n      var rhsTex = rhs.toTex(options);\n      if (parens[1]) {\n        rhsTex = '\\\\left(' + rhsTex + '\\\\right)';\n      }\n\n      //handle some exceptions (due to the way LaTeX works)\n      var lhsIdentifier;\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      }\n      else {\n        //Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          //op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n            case 'OperatorNode:divide':\n              lhsTex = '\\\\left(' + lhsTex + '\\\\right)';\n          }\n        case 'OperatorNode:multiply':\n          if (this.implicit && (implicit === 'hide')) {\n            return lhsTex + '~' + rhsTex;\n          }\n      }\n      return lhsTex + op + rhsTex;\n    } else if ((args.length > 2) && ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply'))) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n        if (parens[index]) {\n          arg = '\\\\left(' + arg + '\\\\right)';\n        }\n        return arg;\n      });\n\n      if ((this.getIdentifier() === 'OperatorNode:multiply') && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op)\n    } else {\n      //fall back to formatting as a function call\n      //as this is a fallback, it doesn't use\n      //fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left('\n          + args.map(function (arg) {\n            return arg.toTex(options);\n          }).join(',') + '\\\\right)';\n    }\n  };\n\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}\n\nexports.name = 'OperatorNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\nvar ArgumentsError = require('../error/ArgumentsError');\nvar deepMap = require('../utils/collection/deepMap');\n\nfunction factory (type, config, load, typed) {\n  var AccessorNode            = load(require('./node/AccessorNode'));\n  var ArrayNode               = load(require('./node/ArrayNode'));\n  var AssignmentNode          = load(require('./node/AssignmentNode'));\n  var BlockNode               = load(require('./node/BlockNode'));\n  var ConditionalNode         = load(require('./node/ConditionalNode'));\n  var ConstantNode            = load(require('./node/ConstantNode'));\n  var FunctionAssignmentNode  = load(require('./node/FunctionAssignmentNode'));\n  var IndexNode               = load(require('./node/IndexNode'));\n  var ObjectNode              = load(require('./node/ObjectNode'));\n  var OperatorNode            = load(require('./node/OperatorNode'));\n  var ParenthesisNode         = load(require('./node/ParenthesisNode'));\n  var FunctionNode            = load(require('./node/FunctionNode'));\n  var RangeNode               = load(require('./node/RangeNode'));\n  var SymbolNode              = load(require('./node/SymbolNode'));\n\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.eval();\n   *\n   * Syntax:\n   *\n   *     parse(expr)\n   *     parse(expr, options)\n   *     parse([expr1, expr2, expr3, ...])\n   *     parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     var node = parse('sqrt(3^2 + 4^2)');\n   *     node.compile(math).eval(); // 5\n   *\n   *     var scope = {a:3, b:4}\n   *     var node = parse('a * b'); // 12\n   *     var code = node.compile(math);\n   *     code.eval(scope); // 12\n   *     scope.a = 5;\n   *     code.eval(scope); // 20\n   *\n   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);\n   *     nodes[2].compile(math).eval(); // 12\n   *\n   * @param {string | string[] | Matrix} expr\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  function parse (expr, options) {\n    if (arguments.length != 1 && arguments.length != 2) {\n      throw new ArgumentsError('parse', arguments.length, 1, 2);\n    }\n\n    // pass extra nodes\n    extra_nodes = (options && options.nodes) ? options.nodes : {};\n\n    if (typeof expr === 'string') {\n      // parse a single expression\n      expression = expr;\n      return parseStart();\n    }\n    else if (Array.isArray(expr) || expr instanceof type.Matrix) {\n      // parse an array or matrix with expressions\n      return deepMap(expr, function (elem) {\n        if (typeof elem !== 'string') throw new TypeError('String expected');\n\n        expression = elem;\n        return parseStart();\n      });\n    }\n    else {\n      // oops\n      throw new TypeError('String or matrix expected');\n    }\n  }\n\n  // token types enumeration\n  var TOKENTYPE = {\n    NULL : 0,\n    DELIMITER : 1,\n    NUMBER : 2,\n    SYMBOL : 3,\n    UNKNOWN : 4\n  };\n\n  // map with all delimiters\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\\\"': true,\n    ';': true,\n\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '\\'': true,\n    '=': true,\n    ':': true,\n    '?': true,\n\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  };\n\n  // map with all named delimiters\n  var NAMED_DELIMITERS = {\n    'mod': true,\n    'to': true,\n    'in': true,\n    'and': true,\n    'xor': true,\n    'or': true,\n    'not': true\n  };\n\n  var extra_nodes = {};             // current extra nodes\n  var expression = '';              // current expression\n  var comment = '';                 // last parsed comment\n  var index = 0;                    // current index in expr\n  var c = '';                       // current token character in expr\n  var token = '';                   // current token\n  var token_type = TOKENTYPE.NULL;  // type of the token\n  var nesting_level = 0;            // level of nesting inside parameters, used to ignore newline characters\n  var conditional_level = null;     // when a conditional is being parsed, the level of the conditional is stored here\n\n  /**\n   * Get the first character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function first() {\n    index = 0;\n    c = expression.charAt(0);\n    nesting_level = 0;\n    conditional_level = null;\n  }\n\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function next() {\n    index++;\n    c = expression.charAt(index);\n  }\n\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function prevPreview() {\n    return expression.charAt(index - 1);\n  }\n\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextPreview() {\n    return expression.charAt(index + 1);\n  }\n\n  /**\n   * Preview the second next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextNextPreview() {\n    return expression.charAt(index + 2);\n  }\n\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and token_type\n   * @private\n   */\n  function getToken() {\n    token_type = TOKENTYPE.NULL;\n    token = '';\n    comment = '';\n\n    // skip over whitespaces\n    // space, tab, and newline when inside parameters\n    while (parse.isWhitespace(c, nesting_level)) {\n      next();\n    }\n\n    // skip comment\n    if (c == '#') {\n      while (c != '\\n' && c != '') {\n        comment += c;\n        next();\n      }\n    }\n\n    // check for end of expression\n    if (c == '') {\n      // token is still empty\n      token_type = TOKENTYPE.DELIMITER;\n      return;\n    }\n\n    // check for new line character\n    if (c == '\\n' && !nesting_level) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c;\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 3 characters\n    var c2 = c + nextPreview();\n    var c3 = c2 + nextNextPreview();\n    if (c3.length == 3 && DELIMITERS[c3]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c3;\n      next();\n      next();\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 2 characters\n    if (c2.length == 2 && DELIMITERS[c2]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c2;\n      next();\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 1 character\n    if (DELIMITERS[c]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c;\n      next();\n      return;\n    }\n\n    // check for a number\n    if (parse.isDigitDot(c)) {\n      token_type = TOKENTYPE.NUMBER;\n\n      // get number, can have a single dot\n      if (c == '.') {\n        token += c;\n        next();\n\n        if (!parse.isDigit(c)) {\n          // this is no number, it is just a dot (can be dot notation)\n          token_type = TOKENTYPE.DELIMITER;\n        }\n      }\n      else {\n        while (parse.isDigit(c)) {\n          token += c;\n          next();\n        }\n        if (parse.isDecimalMark(c, nextPreview())) {\n          token += c;\n          next();\n        }\n      }\n      while (parse.isDigit(c)) {\n        token += c;\n        next();\n      }\n\n      // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n      c2 = nextPreview();\n      if (c == 'E' || c == 'e') {\n        if (parse.isDigit(c2) || c2 == '-' || c2 == '+') {\n          token += c;\n          next();\n\n          if (c == '+' || c == '-') {\n            token += c;\n            next();\n          }\n\n          // Scientific notation MUST be followed by an exponent\n          if (!parse.isDigit(c)) {\n            throw createSyntaxError('Digit expected, got \"' + c + '\"');\n          }\n\n          while (parse.isDigit(c)) {\n            token += c;\n            next();\n          }\n\n          if (parse.isDecimalMark(c, nextPreview())) {\n            throw createSyntaxError('Digit expected, got \"' + c + '\"');\n          }\n        }\n        else if (c2 == '.') {\n          next();\n          throw createSyntaxError('Digit expected, got \"' + c + '\"');\n        }\n      }\n\n      return;\n    }\n\n    // check for variables, functions, named operators\n    if (parse.isAlpha(c, prevPreview(), nextPreview())) {\n      while (parse.isAlpha(c, prevPreview(), nextPreview()) || parse.isDigit(c)) {\n        token += c;\n        next();\n      }\n\n      if (NAMED_DELIMITERS.hasOwnProperty(token)) {\n        token_type = TOKENTYPE.DELIMITER;\n      }\n      else {\n        token_type = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    }\n\n    // something unknown is found, wrong characters -> a syntax error\n    token_type = TOKENTYPE.UNKNOWN;\n    while (c != '') {\n      token += c;\n      next();\n    }\n    throw createSyntaxError('Syntax error in part \"' + token + '\"');\n  }\n\n  /**\n   * Get next token and skip newline tokens\n   */\n  function getTokenSkipNewline () {\n    do {\n      getToken();\n    }\n    while (token == '\\n');\n  }\n\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams() is called\n   */\n  function openParams() {\n    nesting_level++;\n  }\n\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n  function closeParams() {\n    nesting_level--;\n  }\n\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n  parse.isAlpha = function isAlpha (c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c)\n        || parse.isValidMathSymbol(c, cNext)\n        || parse.isValidMathSymbol(cPrev, c);\n  };\n\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek (c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * http://unicode-table.com/en/\n   * http://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * http://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n  parse.isValidMathSymbol = function isValidMathSymbol (high, low) {\n    return /^[\\uD835]$/.test(high) &&\n        /^[\\uDC00-\\uDFFF]$/.test(low) &&\n        /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n  parse.isWhitespace = function isWhitespace (c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c == ' ' || c == '\\t' || (c == '\\n' && nestingLevel > 0);\n  };\n\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n  parse.isDecimalMark = function isDecimalMark (c, cNext) {\n    return c == '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigitDot = function isDigitDot (c) {\n    return ((c >= '0' && c <= '9') || c == '.');\n  };\n\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigit = function isDigit (c) {\n    return (c >= '0' && c <= '9');\n  };\n\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n  function parseStart () {\n    // get the first character in expression\n    first();\n\n    getToken();\n\n    var node = parseBlock();\n\n    // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and token_type DELIMITER\n    if (token != '') {\n      if (token_type == TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean != ?\"\n        throw createError('Unexpected operator ' + token);\n      }\n      else {\n        throw createSyntaxError('Unexpected part \"' + token + '\"');\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n  function parseBlock () {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (token != '' && token != '\\n' && token != ';') {\n      node = parseAssignment();\n      node.comment = comment;\n    }\n\n    // TODO: simplify this loop\n    while (token == '\\n' || token == ';') {\n      if (blocks.length == 0 && node) {\n        visible = (token != ';');\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken();\n      if (token != '\\n' && token != ';' && token != '') {\n        node = parseAssignment();\n        node.comment = comment;\n\n        visible = (token != ';');\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    }\n    else {\n      if (!node) {\n        node = new ConstantNode('undefined', 'undefined');\n        node.comment = comment;\n      }\n\n      return node\n    }\n  }\n\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n  function parseAssignment () {\n    var name, args, value, valid;\n\n    var node = parseConditional();\n\n    if (token == '=') {\n      if (type.isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline();\n        value = parseAssignment();\n        return new AssignmentNode(new SymbolNode(name), value);\n      }\n      else if (type.isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline();\n        value = parseAssignment();\n        return new AssignmentNode(node.object, node.index, value);\n      }\n      else if (type.isFunctionNode(node) && type.isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (type.isSymbolNode(arg)) {\n            args[index] = arg.name;\n          }\n          else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline();\n          value = parseAssignment();\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError('Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseConditional () {\n    var node = parseLogicalOr();\n\n    while (token == '?') {\n      // set a conditional level, the range operator will be ignored as long\n      // as conditional_level == nesting_level.\n      var prev = conditional_level;\n      conditional_level = nesting_level;\n      getTokenSkipNewline();\n\n      var condition = node;\n      var trueExpr = parseAssignment();\n\n      if (token != ':') throw createSyntaxError('False part of conditional expression expected');\n\n      conditional_level = null;\n      getTokenSkipNewline();\n\n      var falseExpr = parseAssignment(); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr);\n\n      // restore the previous conditional level\n      conditional_level = prev;\n    }\n\n    return node;\n  }\n\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalOr() {\n    var node = parseLogicalXor();\n\n    while (token == 'or') {\n      getTokenSkipNewline();\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalXor() {\n    var node = parseLogicalAnd();\n\n    while (token == 'xor') {\n      getTokenSkipNewline();\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalAnd() {\n    var node = parseBitwiseOr();\n\n    while (token == 'and') {\n      getTokenSkipNewline();\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseOr() {\n    var node = parseBitwiseXor();\n\n    while (token == '|') {\n      getTokenSkipNewline();\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseXor() {\n    var node = parseBitwiseAnd();\n\n    while (token == '^|') {\n      getTokenSkipNewline();\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseAnd () {\n    var node = parseRelational();\n\n    while (token == '&') {\n      getTokenSkipNewline();\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * relational operators\n   * @return {Node} node\n   * @private\n   */\n  function parseRelational () {\n    var node, operators, name, fn, params;\n\n    node = parseShift();\n\n    operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseShift()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n  function parseShift () {\n    var node, operators, name, fn, params;\n\n    node = parseConversion();\n\n    operators = {\n      '<<' : 'leftShift',\n      '>>' : 'rightArithShift',\n      '>>>' : 'rightLogShift'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseConversion()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n  function parseConversion () {\n    var node, operators, name, fn, params;\n\n    node = parseRange();\n\n    operators = {\n      'to' : 'to',\n      'in' : 'to'   // alias of 'to'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      \n      if (name === 'in' && token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      }\n      else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange()];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n  function parseRange () {\n    var node, params = [];\n\n    if (token == ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode('1', 'number');\n    }\n    else {\n      // explicit start\n      node = parseAddSubtract();\n    }\n\n    if (token == ':' && (conditional_level !== nesting_level)) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node);\n\n      // parse step and end\n      while (token == ':' && params.length < 3) {\n        getTokenSkipNewline();\n\n        if (token == ')' || token == ']' || token == ',' || token == '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        }\n        else {\n          // explicit end\n          params.push(parseAddSubtract());\n        }\n      }\n\n      if (params.length == 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      }\n      else { // length == 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n  function parseAddSubtract ()  {\n    var node, operators, name, fn, params;\n\n    node = parseMultiplyDivide();\n\n    operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseMultiplyDivide()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n  function parseMultiplyDivide () {\n    var node, last, operators, name, fn;\n\n    node = parseUnary();\n    last = node;\n\n    operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      'mod': 'mod'\n    };\n\n    while (true) {\n      if (operators.hasOwnProperty(token)) {\n        // explicit operators\n        name = token;\n        fn = operators[name];\n\n        getTokenSkipNewline();\n\n        last = parseUnary();\n        node = new OperatorNode(name, fn, [node, last]);\n      }\n      else if ((token_type === TOKENTYPE.SYMBOL) ||\n          (token === 'in' && type.isConstantNode(node)) ||\n          (token_type === TOKENTYPE.NUMBER &&\n              !type.isConstantNode(last) &&\n              (!type.isOperatorNode(last) || last.op === '!')) ||\n          (token === '(')) {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseUnary();\n        node = new OperatorNode('*', 'multiply', [node, last], true /*implicit*/);\n      }\n      else {\n        break;\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n  function parseUnary () {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      'not': 'not'\n    };\n\n    if (operators.hasOwnProperty(token)) {\n      fn = operators[token];\n      name = token;\n\n      getTokenSkipNewline();\n      params = [parseUnary()];\n\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow();\n  }\n\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n  function parsePow () {\n    var node, name, fn, params;\n\n    node = parseLeftHandOperators();\n\n    if (token == '^' || token == '.^') {\n      name = token;\n      fn = (name == '^') ? 'pow' : 'dotPow';\n\n      getTokenSkipNewline();\n      params = [node, parseUnary()]; // Go back to unary, we can have '2^-3'\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * Left hand operators: factorial x!, transpose x'\n   * @return {Node} node\n   * @private\n   */\n  function parseLeftHandOperators ()  {\n    var node, operators, name, fn, params;\n\n    node = parseCustomNodes();\n\n    operators = {\n      '!': 'factorial',\n      '\\'': 'transpose'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getToken();\n      params = [node];\n\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.expression.node.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     };\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params);\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes);\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseCustomNodes () {\n    var params = [];\n\n    if (token_type == TOKENTYPE.SYMBOL && extra_nodes.hasOwnProperty(token)) {\n      var CustomNode = extra_nodes[token];\n\n      getToken();\n\n      // parse parameters\n      if (token == '(') {\n        params = [];\n\n        openParams();\n        getToken();\n\n        if (token != ')') {\n          params.push(parseAssignment());\n\n          // parse a list with parameters\n          while (token == ',') {\n            getToken();\n            params.push(parseAssignment());\n          }\n        }\n\n        if (token != ')') {\n          throw createSyntaxError('Parenthesis ) expected');\n        }\n        closeParams();\n        getToken();\n      }\n\n      // create a new custom node\n      //noinspection JSValidateTypes\n      return new CustomNode(params);\n    }\n\n    return parseSymbol();\n  }\n\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n  function parseSymbol () {\n    var node, name;\n\n    if (token_type == TOKENTYPE.SYMBOL ||\n        (token_type == TOKENTYPE.DELIMITER && token in NAMED_DELIMITERS)) {\n      name = token;\n\n      getToken();\n\n      // parse function parameters and matrix index\n      node = new SymbolNode(name);\n      node = parseAccessors(node);\n      return node;\n    }\n\n    return parseString();\n  }\n\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n  function parseAccessors (node, types) {\n    var params;\n\n    while ((token === '(' || token === '[' || token === '.') &&\n        (!types || types.indexOf(token) !== -1)) {\n      params = [];\n\n      if (token === '(') {\n        if (type.isSymbolNode(node) || type.isAccessorNode(node) || type.isFunctionNode(node)) {\n          // function invocation like fn(2, 3)\n          openParams();\n          getToken();\n\n          if (token !== ')') {\n            params.push(parseAssignment());\n\n            // parse a list with parameters\n            while (token === ',') {\n              getToken();\n              params.push(parseAssignment());\n            }\n          }\n\n          if (token !== ')') {\n            throw createSyntaxError('Parenthesis ) expected');\n          }\n          closeParams();\n          getToken();\n\n          node = new FunctionNode(node, params);\n        }\n        else {\n          // implicit multiplication like (2+3)(4+5)\n          // don't parse it here but let it be handled by parseMultiplyDivide\n          // with correct precedence\n          return node;\n        }\n      }\n      else if (token === '[') {\n        // index notation like variable[2, 3]\n        openParams();\n        getToken();\n\n        if (token !== ']') {\n          params.push(parseAssignment());\n\n          // parse a list with parameters\n          while (token === ',') {\n            getToken();\n            params.push(parseAssignment());\n          }\n        }\n\n        if (token !== ']') {\n          throw createSyntaxError('Parenthesis ] expected');\n        }\n        closeParams();\n        getToken();\n\n        node = new AccessorNode(node, new IndexNode(params));\n      }\n      else {\n        // dot notation like variable.prop\n        getToken();\n\n        if (token_type !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError('Property name expected after dot');\n        }\n        params.push(new ConstantNode(token));\n        getToken();\n\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * parse a string.\n   * A string is enclosed by double quotes\n   * @return {Node} node\n   * @private\n   */\n  function parseString () {\n    var node, str;\n\n    if (token == '\"') {\n      str = parseStringToken();\n\n      // create constant\n      node = new ConstantNode(str, 'string');\n\n      // parse index parameters\n      node = parseAccessors(node);\n\n      return node;\n    }\n\n    return parseMatrix();\n  }\n\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n  function parseStringToken () {\n    var str = '';\n\n    while (c != '' && c != '\\\"') {\n      if (c == '\\\\') {\n        // escape character\n        str += c;\n        next();\n      }\n\n      str += c;\n      next();\n    }\n\n    getToken();\n    if (token != '\"') {\n      throw createSyntaxError('End of string \" expected');\n    }\n    getToken();\n\n    return str;\n  }\n\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n  function parseMatrix () {\n    var array, params, rows, cols;\n\n    if (token == '[') {\n      // matrix [...]\n      openParams();\n      getToken();\n\n      if (token != ']') {\n        // this is a non-empty matrix\n        var row = parseRow();\n\n        if (token == ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row];\n\n          // the rows of the matrix are separated by dot-comma's\n          while (token == ';') {\n            getToken();\n\n            params[rows] = parseRow();\n            rows++;\n          }\n\n          if (token != ']') {\n            throw createSyntaxError('End of matrix ] expected');\n          }\n          closeParams();\n          getToken();\n\n          // check if the number of columns matches in all rows\n          cols = params[0].items.length;\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length != cols) {\n              throw createError('Column dimensions mismatch ' +\n                  '(' + params[r].items.length + ' != ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        }\n        else {\n          // 1 dimensional vector\n          if (token != ']') {\n            throw createSyntaxError('End of matrix ] expected');\n          }\n          closeParams();\n          getToken();\n\n          array = row;\n        }\n      }\n      else {\n        // this is an empty matrix \"[ ]\"\n        closeParams();\n        getToken();\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(array);\n    }\n\n    return parseObject();\n  }\n\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n  function parseRow () {\n    var params = [parseAssignment()];\n    var len = 1;\n\n    while (token == ',') {\n      getToken();\n\n      // parse expression\n      params[len] = parseAssignment();\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n  function parseObject () {\n    if (token == '{') {\n      var key;\n\n      var properties = {};\n      do {\n        getToken();\n\n        if (token != '}') {\n          // parse key\n          if (token == '\"') {\n            key = parseStringToken();\n          }\n          else if (token_type == TOKENTYPE.SYMBOL) {\n            key = token;\n            getToken();\n          }\n          else {\n            throw createSyntaxError('Symbol or string expected as object key');\n          }\n\n          // parse key/value separator\n          if (token != ':') {\n            throw createSyntaxError('Colon : expected after object key');\n          }\n          getToken();\n\n          // parse key\n          properties[key] = parseAssignment();\n        }\n      }\n      while (token == ',');\n\n      if (token != '}') {\n        throw createSyntaxError('Comma , or bracket } expected after object value');\n      }\n      getToken();\n\n      var node = new ObjectNode(properties);\n\n      // parse index parameters\n      node = parseAccessors(node);\n\n      return node;\n    }\n\n    return parseNumber();\n  }\n\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n  function parseNumber () {\n    var number;\n\n    if (token_type == TOKENTYPE.NUMBER) {\n      // this is a number\n      number = token;\n      getToken();\n\n      return new ConstantNode(number, 'number');\n    }\n\n    return parseParentheses();\n  }\n\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n  function parseParentheses () {\n    var node;\n\n    // check if it is a parenthesized expression\n    if (token == '(') {\n      // parentheses (...)\n      openParams();\n      getToken();\n\n      node = parseAssignment(); // start again\n\n      if (token != ')') {\n        throw createSyntaxError('Parenthesis ) expected');\n      }\n      closeParams();\n      getToken();\n\n      node = new ParenthesisNode(node);\n      node = parseAccessors(node);\n      return node;\n    }\n\n    return parseEnd();\n  }\n\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n  function parseEnd () {\n    if (token == '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError('Unexpected end of expression');\n    } else if (token === \"'\") {\n      throw createSyntaxError('Value expected. Note: strings must be enclosed by double quotes');\n    } else {\n      throw createSyntaxError('Value expected');\n    }\n  }\n\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null;\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last token starts\n   * @private\n   */\n  function col () {\n    return index - token.length + 1;\n  }\n\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n  function createSyntaxError (message) {\n    var c = col();\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n\n    return error;\n  }\n\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n  function createError (message) {\n    var c = col();\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n\n    return error;\n  }\n\n  return parse;\n}\n\nexports.name = 'parse';\nexports.path = 'expression';\nexports.factory = factory;\n","'use strict';\n\nvar digits = require('./../../../utils/number').digits;\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nfunction factory(type, config, load, typed, math) {\n  var util = load(require('./util'));\n  var isCommutative = util.isCommutative;\n  var isAssociative = util.isAssociative;\n  var allChildren = util.allChildren;\n  var createMakeNodeFunction = util.createMakeNodeFunction;\n  var ConstantNode = math.expression.node.ConstantNode;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var FunctionNode = math.expression.node.FunctionNode;\n\n  function simplifyConstant(expr) {\n    var res = foldFraction(expr);\n    return type.isNode(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args) {\n    try {\n      return _toNumber(math[fnname].apply(null, args));\n    }\n    catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function(x){\n        if (type.isFraction(x)) {\n          return x.valueOf();\n        }\n        return x;\n      });\n      return _toNumber(math[fnname].apply(null, args));\n    }\n  }\n\n  var _toNode = typed({\n    'Fraction': _fractionToNode,\n    'number': function(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    'BigNumber': function(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(n.negated().toString(), 'number'));\n      }\n      return new ConstantNode(n.toString(), 'number');\n    },\n    'Complex': function(s) {\n      throw 'Cannot convert Complex number to Node';\n    }\n  });\n\n  // convert a number to a fraction only if it can be expressed exactly\n  function _exactFraction(n) {\n    if (isFinite(n)) {\n      var f = math.fraction(n);\n      if (f.valueOf() === n) {\n        return f;\n      }\n    }\n    return n;\n  }\n\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n  var _toNumber = typed({\n    'string': function(s) {\n      if (config.number === 'BigNumber') {\n        return math.bignumber(s);\n      }\n      else if (config.number === 'Fraction') {\n        return math.fraction(s);\n      }\n      else {\n        return _exactFraction(parseFloat(s));\n      }\n    },\n\n    'Fraction': function(s) { return s; },\n\n    'BigNumber': function(s) { return s; },\n\n    'number': function(s) {\n      return _exactFraction(s);\n    },\n\n    'Complex': function(s) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re);\n    },\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s*f.n;\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)])\n    }\n    else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n  function foldOp(fn, args, makeNode) {\n    return args.reduce(function(a, b) {\n      if (!type.isNode(a) && !type.isNode(b)) {\n        try {\n          return _eval(fn, [a,b]);\n        }\n        catch (ignoreandcontinue) {}\n        a = _toNode(a);\n        b = _toNode(b);\n      }\n      else if (!type.isNode(a)) {\n        a = _toNode(a);\n      }\n      else if (!type.isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  }\n\n  // destroys the original node and returns a folded one\n  function foldFraction(node) {\n    switch(node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        if (node.valueType === 'number') {\n          return _toNumber(node.value);\n        }\n        return node;\n      case 'FunctionNode':\n        if (math[node.name] && math[node.name].rawArgs) {\n          return node;\n        }\n\n        // Process operators as OperatorNode\n        var operatorFunctions = [ 'add', 'multiply' ];\n        if (operatorFunctions.indexOf(node.name) === -1) {\n          var args = node.args.map(foldFraction);\n\n          // If all args are numbers\n          if (!args.some(type.isNode)) {\n            try {\n              return _eval(node.name, args);\n            }\n            catch (ignoreandcontine) {}\n          }\n\n          // Convert all args to nodes and construct a symbolic function call\n          args = args.map(function(arg) {\n            return type.isNode(arg) ? arg : _toNode(arg);\n          });\n          return new FunctionNode(node.name, args);\n        }\n        else {\n          // treat as operator\n        }\n        /* falls through */\n      case 'OperatorNode':\n        var fn = node.fn.toString();\n        var args;\n        var res;\n        var makeNode = createMakeNodeFunction(node);\n        if (node.args.length === 1) {\n          args = [foldFraction(node.args[0])];\n          if (!type.isNode(args[0])) {\n            res = _eval(fn, args);\n          }\n          else {\n            res = makeNode(args);\n          }\n        }\n        else if (isAssociative(node)) {\n          args = allChildren(node);\n          args = args.map(foldFraction);\n\n          if (isCommutative(fn)) {\n            // commutative binary operator\n            var consts = [], vars = [];\n\n            for (var i=0; i < args.length; i++) {\n              if (!type.isNode(args[i])) {\n                consts.push(args[i]);\n              }\n              else {\n                vars.push(args[i]);\n              }\n            }\n\n            if (consts.length > 1) {\n              res = foldOp(fn, consts, makeNode);\n              vars.unshift(res);\n              res = foldOp(fn, vars, makeNode);\n            }\n            else {\n              // we won't change the children order since it's not neccessary\n              res = foldOp(fn, args, makeNode);\n            }\n          }\n          else {\n            // non-commutative binary operator\n            res = foldOp(fn, args, makeNode);\n          }\n        }\n        else {\n          // non-associative binary operator\n          args = node.args.map(foldFraction);\n          res = foldOp(fn, args, makeNode);\n        }\n        return res;\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content);\n      case 'AccessorNode':\n        /* falls through */\n      case 'ArrayNode':\n        /* falls through */\n      case 'AssignmentNode':\n        /* falls through */\n      case 'BlockNode':\n        /* falls through */\n      case 'FunctionAssignmentNode':\n        /* falls through */\n      case 'IndexNode':\n        /* falls through */\n      case 'ObjectNode':\n        /* falls through */\n      case 'RangeNode':\n        /* falls through */\n      case 'UpdateNode':\n        /* falls through */\n      case 'ConditionalNode':\n        /* falls through */\n      default:\n        throw 'Unimplemented node type in simplifyConstant: '+node.type;\n    }\n  }\n\n  return simplifyConstant;\n}\n\nexports.math = true;\nexports.name = 'simplifyConstant';\nexports.path = 'algebra.simplify';\nexports.factory = factory;\n","// the compile functions which compile a Node into JavaScript are not\n// exposed as class methods for security reasons to prevent being able to\n// override them or create fake Nodes. Instead, only compile functions of\n// registered nodes can be executed\n\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\n\nfunction factory () {\n  // map with node type as key and compile functions as value\n  var compileFunctions = {}\n\n  /**\n   * Register a compile function for a node\n   * @param {string} type\n   * @param {function} compileFunction\n   *                      The compile function, invoked as\n   *                      compileFunction(node, defs, args)\n   */\n  function register(type, compileFunction) {\n    if (compileFunctions[type] === undefined) {\n      compileFunctions[type] = compileFunction;\n    }\n    else {\n      throw new Error('Cannot register type \"' + type + '\": already exists');\n    }\n  }\n\n  /**\n   * Compile a Node into JavaScript\n   * @param {Node} node\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} Returns JavaScript code\n   */\n  function compile (node, defs, args) {\n    if (hasOwnProperty(compileFunctions, node.type)) {\n      var compileFunction = compileFunctions[node.type];\n      return compileFunction(node, defs, args);\n    }\n    else if (typeof node._compile === 'function' &&\n        !hasOwnProperty(node, '_compile')) {\n      // Compatibility for CustomNodes\n      // TODO: this is a security risk, change it such that you have to register CustomNodes separately in math.js, like math.expression.node.register(MyCustomNode)\n      return node._compile(defs, args);\n    }\n    else {\n      throw new Error('Cannot compile node: unknown type \"' + node.type + '\"');\n    }\n  }\n\n  return {\n    register: register,\n    compile: compile\n  }\n}\n\nexports.factory = factory;\n","'use strict';\n\nvar number = require('../../utils/number');\n\nfunction factory (type, config, load, typed) {\n  /**\n   * Create a range. A range has a start, step, and end, and contains functions\n   * to iterate over the range.\n   *\n   * A range can be constructed as:\n   *     var range = new Range(start, end);\n   *     var range = new Range(start, end, step);\n   *\n   * To get the result of the range:\n   *     range.forEach(function (x) {\n   *         console.log(x);\n   *     });\n   *     range.map(function (x) {\n   *         return math.sin(x);\n   *     });\n   *     range.toArray();\n   *\n   * Example usage:\n   *     var c = new Range(2, 6);         // 2:1:5\n   *     c.toArray();                     // [2, 3, 4, 5]\n   *     var d = new Range(2, -3, -1);    // 2:-1:-2\n   *     d.toArray();                     // [2, 1, 0, -1, -2]\n   *\n   * @class Range\n   * @constructor Range\n   * @param {number} start  included lower bound\n   * @param {number} end    excluded upper bound\n   * @param {number} [step] step size, default value is 1\n   */\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (start != null) {\n      if (type.isBigNumber(start))\n        start = start.toNumber();\n      else if (typeof start !== 'number')\n        throw new TypeError('Parameter start must be a number');\n    }\n    if (end != null) {\n      if (type.isBigNumber(end))\n        end = end.toNumber();\n      else if (typeof end !== 'number')\n        throw new TypeError('Parameter end must be a number');\n    }\n    if (step != null) {\n      if (type.isBigNumber(step))\n        step = step.toNumber();\n      else if (typeof step !== 'number')\n        throw new TypeError('Parameter step must be a number');\n    }\n\n    this.start = (start != null) ? parseFloat(start) : 0;\n    this.end   = (end != null)   ? parseFloat(end)   : 0;\n    this.step  = (step != null)  ? parseFloat(step)  : 1;\n  }\n\n  /**\n   * Attach type information\n   */\n  Range.prototype.type = 'Range';\n  Range.prototype.isRange = true;\n\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @memberof Range\n   * @param {string} str\n   * @return {Range | null} range\n   */\n  Range.parse = function (str) {\n    if (typeof str !== 'string') {\n      return null;\n    }\n\n    var args = str.split(':');\n    var nums = args.map(function (arg) {\n      return parseFloat(arg);\n    });\n\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return new Range(nums[0], nums[1]);\n      case 3:\n        return new Range(nums[0], nums[2], nums[1]);\n      default:\n        return null;\n    }\n  };\n\n  /**\n   * Create a clone of the range\n   * @return {Range} clone\n   */\n  Range.prototype.clone = function () {\n    return new Range(this.start, this.end, this.step);\n  };\n\n  /**\n   * Retrieve the size of the range.\n   * Returns an array containing one number, the number of elements in the range.\n   * @memberof Range\n   * @returns {number[]} size\n   */\n  Range.prototype.size = function () {\n    var len = 0,\n        start = this.start,\n        step = this.step,\n        end = this.end,\n        diff = end - start;\n\n    if (number.sign(step) == number.sign(diff)) {\n      len = Math.ceil((diff) / step);\n    }\n    else if (diff == 0) {\n      len = 0;\n    }\n\n    if (isNaN(len)) {\n      len = 0;\n    }\n    return [len];\n  };\n\n  /**\n   * Calculate the minimum value in the range\n   * @memberof Range\n   * @return {number | undefined} min\n   */\n  Range.prototype.min = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start;\n      }\n      else {\n        // negative step\n        return this.start + (size - 1) * this.step;\n      }\n    }\n    else {\n      return undefined;\n    }\n  };\n\n  /**\n   * Calculate the maximum value in the range\n   * @memberof Range\n   * @return {number | undefined} max\n   */\n  Range.prototype.max = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start + (size - 1) * this.step;\n      }\n      else {\n        // negative step\n        return this.start;\n      }\n    }\n    else {\n      return undefined;\n    }\n  };\n\n\n  /**\n   * Execute a callback function for each value in the range.\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Range being traversed.\n   */\n  Range.prototype.forEach = function (callback) {\n    var x = this.start;\n    var step = this.step;\n    var end = this.end;\n    var i = 0;\n\n    if (step > 0) {\n      while (x < end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n    else if (step < 0) {\n      while (x > end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n  };\n\n  /**\n   * Execute a callback function for each value in the Range, and return the\n   * results as an array\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @returns {Array} array\n   */\n  Range.prototype.map = function (callback) {\n    var array = [];\n    this.forEach(function (value, index, obj) {\n      array[index[0]] = callback(value, index, obj);\n    });\n    return array;\n  };\n\n  /**\n   * Create an Array with a copy of the Ranges data\n   * @memberof Range\n   * @returns {Array} array\n   */\n  Range.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (value, index) {\n      array[index[0]] = value;\n    });\n    return array;\n  };\n\n  /**\n   * Get the primitive value of the Range, a one dimensional array\n   * @memberof Range\n   * @returns {Array} array\n   */\n  Range.prototype.valueOf = function () {\n    // TODO: implement a caching mechanism for range.valueOf()\n    return this.toArray();\n  };\n\n  /**\n   * Get a string representation of the range, with optional formatting options.\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\n   * @memberof Range\n   * @param {Object | number | function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n  Range.prototype.format = function (options) {\n    var str = number.format(this.start, options);\n\n    if (this.step != 1) {\n      str += ':' + number.format(this.step, options);\n    }\n    str += ':' + number.format(this.end, options);\n    return str;\n  };\n\n  /**\n   * Get a string representation of the range.\n   * @memberof Range\n   * @returns {string}\n   */\n  Range.prototype.toString = function () {\n    return this.format();\n  };\n\n  /**\n   * Get a JSON representation of the range\n   * @memberof Range\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   */\n  Range.prototype.toJSON = function () {\n    return {\n      mathjs: 'Range',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n\n  /**\n   * Instantiate a Range from a JSON object\n   * @memberof Range\n   * @param {Object} json A JSON object structured as:\n   *                      `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   * @return {Range}\n   */\n  Range.fromJSON = function (json) {\n    return new Range(json.start, json.end, json.step);\n  };\n\n  return Range;\n}\n\nexports.name = 'Range';\nexports.path = 'type';\nexports.factory = factory;\n","/**\n * Convert a BigNumber to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lower` and `upper` bounds, and uses\n *                                          exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential' and\n *                                          'auto', `precision` defines the total\n *                                          number of significant digits returned\n *                                          and is undefined by default.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point, and is 0 by default.\n *                     {Object} exponential An object containing two parameters,\n *                                          {number} lower and {number} upper,\n *                                          used by notation 'auto' to determine\n *                                          when to return exponential notation.\n *                                          Default values are `lower=1e-3` and\n *                                          `upper=1e5`.\n *                                          Only applicable for notation `auto`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4);                                        // '6.4'\n *    format(1240000);                                    // '1.24e6'\n *    format(1/3);                                        // '0.3333333333333333'\n *    format(1/3, 3);                                     // '0.333'\n *    format(21385, 2);                                   // '21000'\n *    format(12.071, {notation: 'fixed'});                // '12'\n *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'\n *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'\n *\n * @param {BigNumber} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\nexports.format = function (value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  }\n\n  // handle special cases\n  if (!value.isFinite()) {\n    return value.isNaN() ? 'NaN' : (value.gt(0) ? 'Infinity' : '-Infinity');\n  }\n\n  // default values for options\n  var notation = 'auto';\n  var precision = undefined;\n\n  if (options !== undefined) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    }\n\n    // determine precision from options\n    if (typeof options === 'number') {\n      precision = options;\n    }\n    else if (options.precision) {\n      precision = options.precision;\n    }\n  }\n\n  // handle the various notations\n  switch (notation) {\n    case 'fixed':\n      return exports.toFixed(value, precision);\n\n    case 'exponential':\n      return exports.toExponential(value, precision);\n\n    case 'auto':\n      // determine lower and upper bound for exponential notation.\n      // TODO: implement support for upper and lower to be BigNumbers themselves\n      var lower = 1e-3;\n      var upper = 1e5;\n      if (options && options.exponential) {\n        if (options.exponential.lower !== undefined) {\n          lower = options.exponential.lower;\n        }\n        if (options.exponential.upper !== undefined) {\n          upper = options.exponential.upper;\n        }\n      }\n\n      // adjust the configuration of the BigNumber constructor (yeah, this is quite tricky...)\n      var oldConfig = {\n        toExpNeg: value.constructor.toExpNeg,\n        toExpPos: value.constructor.toExpPos\n      };\n\n      value.constructor.config({\n        toExpNeg: Math.round(Math.log(lower) / Math.LN10),\n        toExpPos: Math.round(Math.log(upper) / Math.LN10)\n      });\n\n      // handle special case zero\n      if (value.isZero()) return '0';\n\n      // determine whether or not to output exponential notation\n      var str;\n      var abs = value.abs();\n      if (abs.gte(lower) && abs.lt(upper)) {\n        // normal number notation\n        str = value.toSignificantDigits(precision).toFixed();\n      }\n      else {\n        // exponential notation\n        str = exports.toExponential(value, precision);\n      }\n\n      // remove trailing zeros after the decimal point\n      return str.replace(/((\\.\\d*?)(0+))($|e)/, function () {\n        var digits = arguments[2];\n        var e = arguments[4];\n        return (digits !== '.') ? digits + e : e;\n      });\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' +\n          'Choose \"auto\", \"exponential\", or \"fixed\".');\n  }\n};\n\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {BigNumber} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n * @returns {string} str\n */\nexports.toExponential = function (value, precision) {\n  if (precision !== undefined) {\n    return value.toExponential(precision - 1); // Note the offset of one\n  }\n  else {\n    return value.toExponential();\n  }\n};\n\n/**\n * Format a number with fixed notation.\n * @param {BigNumber} value\n * @param {number} [precision=0]        Optional number of decimals after the\n *                                      decimal point. Zero by default.\n */\nexports.toFixed = function (value, precision) {\n  return value.toFixed(precision || 0);\n  // Note: the (precision || 0) is needed as the toFixed of BigNumber has an\n  // undefined default precision instead of 0.\n};\n","'use strict';\n\nfunction factory (type, config, load, typed) {\n  /**\n   * Create a Matrix. The function creates a new `math.type.Matrix` object from\n   * an `Array`. A Matrix has utility functions to manipulate the data in the\n   * matrix, like getting the size and getting or setting values in the matrix.\n   * Supported storage formats are 'dense' and 'sparse'.\n   *\n   * Syntax:\n   *\n   *    math.matrix()                         // creates an empty matrix using default storage format (dense).\n   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).\n   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.\n   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.\n   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.\n   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.\n   *\n   * Examples:\n   *\n   *    var m = math.matrix([[1, 2], [3, 4]]);\n   *    m.size();                        // Array [2, 2]\n   *    m.resize([3, 2], 5);\n   *    m.valueOf();                     // Array [[1, 2], [3, 4], [5, 5]]\n   *    m.get([1, 0])                    // number 3\n   *\n   * See also:\n   *\n   *    bignumber, boolean, complex, index, number, string, unit, sparse\n   *\n   * @param {Array | Matrix} [data]    A multi dimensional array\n   * @param {string} [format]          The Matrix storage format\n   *\n   * @return {Matrix} The created matrix\n   */\n  var matrix = typed('matrix', {\n    '': function () {\n      return _create([]);\n    },\n\n    'string': function (format) {\n      return _create([], format);\n    },\n    \n    'string, string': function (format, datatype) {\n      return _create([], format, datatype);\n    },\n\n    'Array': function (data) {\n      return _create(data);\n    },\n      \n    'Matrix': function (data) {\n      return _create(data, data.storage());\n    },\n    \n    'Array | Matrix, string': _create,\n    \n    'Array | Matrix, string, string': _create\n  });\n\n  matrix.toTex = {\n    0: '\\\\begin{bmatrix}\\\\end{bmatrix}',\n    1: '\\\\left(${args[0]}\\\\right)',\n    2: '\\\\left(${args[0]}\\\\right)'\n  };\n\n  return matrix;\n\n  /**\n   * Create a new Matrix with given storage format\n   * @param {Array} data\n   * @param {string} [format]\n   * @param {string} [datatype]\n   * @returns {Matrix} Returns a new Matrix\n   * @private\n   */\n  function _create(data, format, datatype) {\n    // get storage format constructor\n    var M = type.Matrix.storage(format || 'default');\n\n    // create instance\n    return new M(data, datatype);\n  }\n}\n\nexports.name = 'matrix';\nexports.factory = factory;\n","'use strict';\n\nvar map = require('../../utils/array').map;\nvar join = require('../../utils/array').join;\nvar escape = require('../../utils/string').escape;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n  var RangeNode = load(require('./RangeNode'));\n  var SymbolNode = load(require('./SymbolNode'));\n\n  var Range = load(require('../../type/matrix/Range'));\n\n  var isArray = Array.isArray;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false;\n\n    // validate input\n    if (!isArray(dimensions) || !dimensions.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n\n    // TODO: deprecated since v3, remove some day\n    var deprecated = function () {\n      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');\n    };\n    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });\n  }\n\n  IndexNode.prototype = new Node();\n\n  IndexNode.prototype.type = 'IndexNode';\n\n  IndexNode.prototype.isIndexNode = true;\n\n  /**\n   * Compile all range nodes\n   *\n   * When some of the dimensions has `end` defined, the IndexNode requires\n   * a variable `size` to be defined in the current closure, and must contain\n   * the size of the matrix that's being handled. To check whether the `size`\n   * variable is needed, call IndexNode.needsSize().\n   *\n   * @param {IndexNode} node        The node to be compiled\n   * @param {Object} defs           Object which can be used to define functions\n   *                                or constants globally available for the\n   *                                compiled expression\n   * @param {Object} args           Object with local function arguments, the key is\n   *                                the name of the argument, and the value is `true`.\n   *                                The object may not be mutated, but must be\n   *                                extended instead.\n   * @return {string} code\n   */\n  function compileIndexNode(node, defs, args) {\n    if (!(node instanceof IndexNode)) {\n      throw new TypeError('No valid IndexNode')\n    }\n\n    // args can be mutated by IndexNode, when dimensions use `end`\n    var childArgs = Object.create(args);\n\n    // helper function to create a Range from start, step and end\n    defs.range = function (start, end, step) {\n      return new Range(\n          type.isBigNumber(start) ? start.toNumber() : start,\n          type.isBigNumber(end)   ? end.toNumber()   : end,\n          type.isBigNumber(step)  ? step.toNumber()  : step\n      );\n    };\n\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n\n    // optimization for a simple object property\n    var dimensions = map(node.dimensions, function (range, i) {\n      if (type.isRangeNode(range)) {\n        if (range.needsEnd()) {\n          childArgs.end = 'end';\n\n          // resolve end and create range\n          return '(function () {' +\n              'var end = size[' + i + ']; ' +\n              'return range(' +\n              compile(range.start, defs, childArgs) + ', ' +\n              compile(range.end, defs, childArgs) + ', ' +\n              (range.step ? compile(range.step, defs, childArgs) : '1') +\n              '); ' +\n              '})()';\n        }\n        else {\n          // create range\n          return 'range(' +\n              compile(range.start, defs, childArgs) + ', ' +\n              compile(range.end, defs, childArgs) + ', ' +\n              (range.step ? compile(range.step, defs, childArgs) : '1') +\n              ')';\n        }\n      }\n      if (type.isSymbolNode(range) && range.name === 'end') {\n        childArgs.end = 'end';\n\n        // resolve the parameter 'end'\n        return '(function () {' +\n            'var end = size[' + i + ']; ' +\n            'return ' + compile(range, defs, childArgs) + '; ' +\n            '})()'\n      }\n      else { // ConstantNode\n        return compile(range, defs, childArgs);\n      }\n    });\n\n    return 'math.index(' + join(dimensions, ', ') + ')';\n  }\n\n  // register the compile function\n  register(IndexNode.prototype.type, compileIndexNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0));\n  };\n\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 &&\n        type.isConstantNode(this.dimensions[0]) &&\n        this.dimensions[0].valueType === 'string';\n  };\n\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation\n        ? ('.' + this.getObjectProperty())\n        : ('[' + this.dimensions.join(', ') + ']');\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n\tvar dimensions = []\n\tfor (var i=0; i<this.dimensions.length; i++)\t{\n\t  dimensions[i] = this.dimensions[i].toHTML();\n\t}\n\tif (this.dotNotation) {\n\t  return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';}\n\telse {\n\t  return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>'}\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n\n    return this.dotNotation\n        ? ('.' + this.getObjectProperty() + '')\n        : ('_{' + dimensions.join(',') + '}');\n  };\n\n  /**\n   * Test whether this IndexNode needs the object size, size of the Matrix\n   * @return {boolean}\n   */\n  IndexNode.prototype.needsSize = function () {\n    return this.dimensions.some(function (range) {\n      return (type.isRangeNode(range) && range.needsEnd()) ||\n          (type.isSymbolNode(range) && range.name === 'end');\n    });\n  };\n\n  return IndexNode;\n}\n\nexports.name = 'IndexNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\n\nfunction factory (type, config, load, typed, math) {\n  var parse = load(require('../../expression/parse'));\n  var ConstantNode = load(require('../../expression/node/ConstantNode'));\n  var FunctionNode = load(require('../../expression/node/FunctionNode'));\n  var OperatorNode = load(require('../../expression/node/OperatorNode'));\n  var ParenthesisNode = load(require('../../expression/node/ParenthesisNode'));\n  var SymbolNode = load(require('../../expression/node/SymbolNode'));\n  var Node = load(require('../../expression/node/Node'));\n  var simplifyConstant = load(require('./simplify/simplifyConstant'));\n  var simplifyCore = load(require('./simplify/simplifyCore'));\n  var resolve = load(require('./simplify/resolve'));\n\n  var util = load(require('./simplify/util'));\n  var isCommutative = util.isCommutative;\n  var isAssociative = util.isAssociative;\n  var flatten = util.flatten;\n  var unflattenr = util.unflattenr;\n  var unflattenl = util.unflattenl;\n  var createMakeNodeFunction = util.createMakeNodeFunction;\n\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     var rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](http://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)');      // Node {2 * x}\n   *     math.simplify('2 * 3 * x', {x: 4});        // Node {24}\n   *     var f = math.parse('2 * 1 * x ^ (2 - 1)');\n   *     math.simplify(f);                          // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative, parse, eval\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n  var simplify = typed('simplify', {\n    'string': function (expr) {\n      return simplify(parse(expr), simplify.rules, {});\n    },\n\n    'string, Object': function (expr, scope) {\n      return simplify(parse(expr), simplify.rules, scope);\n    },\n\n    'string, Array': function (expr, rules) {\n      return simplify(parse(expr), rules, {});\n    },\n\n    'string, Array, Object': function (expr, rules, scope) {\n      return simplify(parse(expr), rules, scope);\n    },\n\n    'Node, Object': function (expr, scope) {\n      return simplify(expr, simplify.rules, scope);\n    },\n\n    'Node': function (expr) {\n      return simplify(expr, simplify.rules, {});\n    },\n\n    'Node, Array': function (expr, rules) {\n      return simplify(expr, rules, {});\n    },\n\n    'Node, Array, Object': function (expr, rules, scope) {\n      rules = _buildRules(rules);\n\n      var res = resolve(expr, scope);\n      var res = removeParens(res);\n      var visited = {};\n\n      var str = res.toString({parenthesis: 'all'});\n      while(!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n        for (var i=0; i<rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res);\n          }\n          else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n        str = res.toString({parenthesis: 'all'});\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function(node, path, parent) {\n      return type.isParenthesisNode(node)\n          ? node.content\n          : node;\n    });\n  }\n\n  // All constants that are allowed in rules\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true,\n    // null: false,\n    // uninitialized: false,\n    // version: false,\n  };\n\n  // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n  simplify.rules = [\n    simplifyCore,\n    //{ l: 'n+0', r: 'n' },     // simplifyCore\n    //{ l: 'n^0', r: '1' },     // simplifyCore\n    //{ l: '0*n', r: '0' },     // simplifyCore\n    //{ l: 'n/n', r: '1'},      // simplifyCore\n    //{ l: 'n^1', r: 'n' },     // simplifyCore\n    //{ l: '+n1', r:'n1' },     // simplifyCore\n    //{ l: 'n--n1', r:'n+n1' }, // simplifyCore\n    { l: 'log(e)', r:'1' },\n\n    // temporary rules\n    { l: 'n-n1', r:'n+-n1' }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    { l: '-(c*v)', r: '(-c) * v' }, // make non-constant terms positive\n    { l: '-v', r: '(-1) * v' },\n    { l: 'n/n1^n2', r:'n*n1^-n2' }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n    { l: 'n/n1', r:'n*n1^-1' },\n\n    // expand nested exponentiation\n    { l: '(n ^ n1) ^ n2', r: 'n ^ (n1 * n2)'},\n\n    // collect like factors\n    { l: 'n*n', r: 'n^2' },\n    { l: 'n * n^n1', r: 'n^(n1+1)' },\n    { l: 'n^n1 * n^n2', r: 'n^(n1+n2)' },\n\n    // collect like terms\n    { l: 'n+n', r: '2*n' },\n    { l: 'n+-n', r: '0' },\n    { l: 'n1*n2 + n2', r: '(n1+1)*n2' },\n    { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n\n    // remove parenthesis in the case of negating a quantitiy\n    { l: 'n1 + -1 * (n2 + n3)', r:'n1 + -1 * n2 + -1 * n3' },\n\n    simplifyConstant,\n\n    { l: '(-n)*n1', r: '-(n*n1)' }, // make factors positive (and undo 'make non-constant terms positive')\n\n    // ordering of constants\n    { l: 'c+v', r: 'v+c', context: { 'add': { commutative:false } } },\n    { l: 'v*c', r: 'c*v', context: { 'multiply': { commutative:false } } },\n\n    // undo temporary rules\n    //{ l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n    { l: 'n+-n1', r:'n-n1' },  // undo replace 'subtract'\n    { l: 'n*(n1^-1)', r:'n/n1' },  // undo replace 'divide'\n    { l: 'n*n1^-n2', r:'n/n1^n2' },\n    { l: 'n1^-1', r:'1/n1' },\n\n    { l: 'n*(n1/n2)', r:'(n*n1)/n2' }, // '*' before '/'\n    { l: 'n-(n1+n2)', r:'n-n1-n2' }, // '-' before '+'\n    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n\n    { l: '1*n', r: 'n' } // this pattern can be produced by simplifyConstant\n\n  ];\n\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n    for(var i=0; i<rules.length; i++) {\n      var rule = rules[i];\n      var newRule;\n      var ruleType = typeof rule;\n      switch (ruleType) {\n        case 'string':\n          var lr = rule.split('->');\n          if (lr.length !== 2) {\n            throw SyntaxError('Could not parse rule: ' + rule);\n          }\n          rule = {l: lr[0], r: lr[1]};\n          /* falls through */\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r)),\n          }\n          if(rule.context) {\n            newRule.evaluate = rule.context;\n          }\n          if(rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n            var expandsym = _getExpandPlaceholderSymbol();\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);\n            // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n          break;\n        case 'function':\n          newRule = rule;\n          break;\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      }\n     // console.log('Adding rule: ' + rules[i]);\n     // console.log(newRule);\n      ruleSet.push(newRule);\n    }\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n  var applyRule = typed('applyRule', {\n    'Node, Object': function (node, rule) {\n\n      //console.log('Entering applyRule(' + node.toString() + ')');\n\n      // Do not clone node unless we find a match\n      var res = node;\n\n      // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for(var i=0; i<res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      }\n      else if(res instanceof ParenthesisNode) {\n        if(res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      }\n\n      // Try to match a rule against this node\n      var repl = rule.r;\n      var matches = _ruleMatch(rule.l, res)[0];\n\n      // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // var before = res.toString({parenthesis: 'all'});\n\n        // Create a new node by cloning the rhs of the matched rule\n        res = repl.clone();\n\n        // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n        var _transform = function(node) {\n          if(node.isSymbolNode && matches.placeholders.hasOwnProperty(node.name)) {\n            return matches.placeholders[node.name].clone();\n          }\n          else {\n            return node.map(_transform);\n          }\n        }\n\n        res = _transform(res);\n\n        // var after = res.toString({parenthesis: 'all'});\n        // console.log('Simplified ' + before + ' to ' + after);\n      }\n\n      return res;\n    }\n  });\n\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n    if (isCommutative(node, context)) {\n      for (var i=0; i<node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = (rightArgs.length === 1) ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    }\n    else {\n      rightArgs = node.args.slice(1);\n      right = (rightArgs.length === 1) ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n    return res;\n  }\n\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n  function mergeMatch(match1, match2) {\n    var res = {placeholders:{}};\n\n    // Some matches may not have placeholders; this is OK\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    }\n    else if (!match1.placeholders) {\n      return match2;\n    }\n    else if (!match2.placeholders) {\n      return match1;\n    }\n\n    // Placeholders with the same key must match exactly\n    for (var key in match1.placeholders) {\n      res.placeholders[key] = match1.placeholders[key];\n      if (match2.placeholders.hasOwnProperty(key)) {\n        if (!_exactMatch(match1.placeholders[key], match2.placeholders[key] )) {\n          return null;\n        }\n      }\n    }\n\n    for (var key in match2.placeholders) {\n      res.placeholders[key] = match2.placeholders[key];\n    }\n\n    return res;\n  }\n\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n    for(var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n    return uniqueSets;\n  }\n\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _ruleMatch(rule, node, isSplit) {\n//    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')');\n//    console.log('rule = ' + rule);\n//    console.log('node = ' + node);\n\n//    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')');\n    var res = [{placeholders:{}}];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode\n     || rule instanceof FunctionNode && node instanceof FunctionNode) {\n\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      }\n      else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      }\n\n      // rule and node match. Search the children of rule and node.\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          }\n          // The child matched, so add the information returned from the child to our result\n          childMatches.push(childMatch);\n        }\n        res = mergeChildMatches(childMatches);\n      }\n      else if (node.args.length >= 2 && rule.args.length === 2) { // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n        for(var i = 0; i < splits.length; i++) {\n          var matchSet = _ruleMatch(rule, splits[i], true); // recursing at the same tree depth here\n          splitMatches = splitMatches.concat(matchSet);\n        }\n        return splitMatches;\n      }\n      else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      }\n      else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    }\n    else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n     if (math.hasOwnProperty(rule.name)) {\n        if (!SUPPORTED_CONSTANTS[rule.name]) {\n          throw new Error('Built in constant: ' + rule.name + ' is not supported by simplify.');\n        }\n\n        // built-in constant must match exactly\n        if(rule.name !== node.name) {\n          return [];\n        }\n      }\n      else if (rule.name[0] === 'n' || rule.name.substring(0,2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      }\n      else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if(!type.isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        }\n        else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      }\n      else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if(node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        }\n        else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      }\n      else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    }\n    else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if(rule.value !== node.value) {\n        return [];\n      }\n    }\n    else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    }\n\n    // It's a match!\n\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match');\n    return res;\n  }\n\n\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _exactMatch(p, q) {\n    if(p instanceof ConstantNode && q instanceof ConstantNode) {\n      if(p.value !== q.value) {\n        return false;\n      }\n    }\n    else if(p instanceof SymbolNode && q instanceof SymbolNode) {\n      if(p.name !== q.name) {\n        return false;\n      }\n    }\n    else if(p instanceof OperatorNode && q instanceof OperatorNode\n         || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      }\n      else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if(p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for(var i=0; i<p.args.length; i++) {\n        if(!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    }\n    else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n}\n\nexports.math = true;\nexports.name = 'simplify';\nexports.factory = factory;\n","/**\n * Test whether a value is a BigNumber\n * @param {*} x\n * @return {boolean}\n */\nmodule.exports = function isBigNumber(x) {\n  return x && x.constructor.prototype.isBigNumber || false\n}\n","module.exports = [\n  require('./integral.js')\n];\n","module.exports = [\n  require('./lib')\n]\n","'use strict';\n\nfunction factory(type, config, load, typed) {\n  var parse = load(require('mathjs/lib/expression/parse'));\n  var simplify = load(require('mathjs/lib/function/algebra/simplify'));\n  var simplifyConstant = load(require('mathjs/lib/function/algebra/simplify/simplifyConstant'));\n  var ConstantNode = load(require('mathjs/lib/expression/node/ConstantNode'));\n  var FunctionNode = load(require('mathjs/lib/expression/node/FunctionNode'));\n  var OperatorNode = load(require('mathjs/lib/expression/node/OperatorNode'));\n  var SymbolNode = load(require('mathjs/lib/expression/node/SymbolNode'));\n\n  /**\n   * Finds the integral of an expression with respect to the given variable.\n   *\n   * The basic algorithm works as follows: the integrand to each function in the\n   * `rules` array, and returns the result of the first function that manages\n   * to find an integral. Each function is also able to recursively call the\n   * integral function, allowing for multiple rules to be applied successively.\n   *\n   * Integration is a rather hard problem, and as such, this implementation can\n   * only find integrals for relatively simple integrands. If it cannot find the\n   * integral for the given expression, it will throw an error.\n   *\n   * @param {Node | string} expr  The expression to be integrated\n   * @param {SymbolNode | string} variable  The variable of integration\n   * @param {{rules: Array.<IntegrationRule>, simplify: boolean, {debugPrint: boolean}}} [options]\n   *        The options for how to integrate: `rules` is the array of rules that\n   *        is applied to the integrand, `simplify` determines wether the output\n   *        is simplified or not, and `debugPrint` determines if the integrator's\n   *        steps are recorded to `console.log` or just ignored\n   * @return {Node} Return the computed integral\n   */\n  var integral = typed('integral', {\n    'Node, SymbolNode, Object': function(expr, variable, options) {\n      // Apply defaults to options object\n      if(options.simplify === undefined) options.simplify = true;\n      if(options.debugPrint === undefined) options.debugPrint = false;\n      if(options.rules === undefined) options.rules = integral.rules;\n\n      // Create an integration context for this integral\n      var context = new IntegrationContext(variable, options);\n\n      // Simplify the integral\n      var simplifiedExpr = preprocessIntegrand(expr, context);\n      var integralResult = _integral(simplifiedExpr, context);\n\n      if(!integralResult) {\n        throw new Error('Unable to find integral of \"' + expr + '\" with respect to \"' + variable + '\"');\n      }\n\n      // Ensure that all nodes are unique\n      integralResult = integralResult.cloneDeep();\n\n      // Return the simplified expression if specified in options, or the unsimplified\n      // integral otherwise\n      return options.simplify === true ? simplify(integralResult) : integralResult;\n    },\n\n    'Node, SymbolNode': function(expr, variable) {\n      return integral(expr, variable, {});\n    },\n\n    'string, SymbolNode, Object': function(expr, variable, options) {\n      return integral(parse(expr), variable, options);\n    },\n\n    'string, SymbolNode': function(expr, variable) {\n      return integral(parse(expr), variable);\n    },\n\n    'Node, string, Object': function(expr, variable, options) {\n      return integral(expr, parse(variable), options);\n    },\n\n    'Node, string': function(expr, variable) {\n      return integral(expr, parse(variable));\n    },\n\n    'string, string, Object': function(expr, variable, options) {\n      return integral(parse(expr), parse(variable), options);\n    },\n\n    'string, string': function(expr, variable) {\n      return integral(parse(expr), parse(variable));\n    }\n\n  });\n\n  /**\n   * @constructor IntegrationContext\n   *\n   * Encapsulates an integration context, including the following: the variable\n   * of integration; a memoizing isConstant function (to determine if a given\n   * expression is constant relative to the variable of integration); and a lookup\n   * table for already computed subintegrals.\n   *\n   * @param {SymbolNode} variable The variable of integration.\n   * @param {Object} options The integration options object.\n   */\n  function IntegrationContext(variable, options) {\n    this.variable = variable.clone();\n    this.options = options;\n\n    this._constantExpr = {};\n    this.subIntegral = {};\n\n    this.rules = options.rules;\n\n    this.debugIndent = 0;\n  }\n\n  /**\n   * Determines if the given expression is constant in this context. An expression\n   * is constant if and only if it does not contain the integration variable for\n   * this context.\n   *\n   * @param {Node} expr The expression to test for constantness.\n   * @return {boolean} True if the expression is constant, false otherwise.\n   */\n  IntegrationContext.prototype.isConstant = function(expr) {\n    if(typeof this._constantExpr[expr] === 'boolean') {\n      return this._constantExpr[expr];\n    } else {\n      // We must determine if this expression is constant ourselves\n      return (this._constantExpr[expr] = isConstantHelper(expr, this));\n    }\n\n    function isConstantHelper(expr, self) {\n      switch(expr.type) {\n        case \"ConstantNode\":\n          return true;\n        case \"SymbolNode\":\n          return expr.name !== self.variable.name;\n        case \"OperatorNode\":\n          return expr.args.every(self.isConstant.bind(self));\n        case \"ParenthesisNode\":\n          return self.isConstant(expr.content);\n        case \"FunctionNode\":\n          return expr.args.every(self.isConstant.bind(self));\n        default:\n          throw new Error(\"Node type '\" + expr.type + \"' is currently unsupported in isConstant.\");\n      }\n    }\n  };\n\n  /**\n   * Print some debug text about cacluating the integral in this context.\n   */\n  IntegrationContext.prototype.printDebug = function(text) {\n    if(this.options.debugPrint) {\n      var indent = \"\";\n      for(var i = 0; i < this.debugIndent; i++) {\n        indent += \"  \";\n      }\n      console.log(indent + text);\n    }\n  }\n\n  /**\n   * Prepare the given expression for integration by\n   *   - Remove parentheses\n   *   - Reduce standard functions into more generic structures:\n   *     - Convert 'add', 'subtract', 'multiply', and 'divide' into their operator counterparts\n   *     - Convert 'sqrt', 'nthRoot', 'exp', and 'pow' into '^' operator\n   *     - Convert 2-arg 'log' into quotient of natrual logarithms\n   *   - Convert division into multiplication to power of -1 (only in non-constant nodes)\n   *\n   * @param {Node} expr  The expression tree representing the integrand to be processed\n   * @param {Object} context  The integration context to interpret the integrand\n   * @return {Node}  The processed integrand\n   */\n  function preprocessIntegrand(expr, context) {\n    expr = removeParenthesis(expr);\n    expr = reduceFunctions(expr);\n    expr = removeDivision(expr);\n    return expr;\n\n    function removeParenthesis(node) {\n      if(node.type === \"ParenthesisNode\") {\n        return removeParenthesis(node.content);\n      } else {\n        return node.map(removeParenthesis);\n      }\n    }\n\n    function reduceFunctions(expr) {\n      return helper(expr);\n\n      function helper(expr) {\n        if(!context.isConstant(expr) && expr.type === \"FunctionNode\") {\n          var funcName = typeof expr.fn === \"string\" ? expr.fn : expr.fn.name;\n\n          switch(funcName) {\n            case \"add\":\n              return new OperatorNode('+', 'add', expr.args);\n            case \"subtract\":\n              return new OperatorNode('-', 'subtract', expr.args);\n            case \"multiply\":\n              return new OperatorNode('*', 'multiply', expr.args);\n            case \"divide\":\n              return new OperatorNode('/', 'divide', expr.args);\n            case \"sqrt\":\n              return new OperatorNode('^', 'pow', [\n                expr.args[0].map(helper),\n                new OperatorNode('/', 'divide', [\n                  new ConstantNode(1),\n                  new ConstantNode(2)\n                ])\n              ]);\n            case \"nthRoot\":\n              return new OperatorNode('^', 'pow', [\n                expr.args[0].map(helper),\n                new OperatorNode('/', 'divide', [\n                  new ConstantNode(1),\n                  expr.args[1].map(helper)\n                ])\n              ]);\n            case \"exp\":\n              return new OperatorNode('^', 'pow', [new SymbolNode('e'), expr.args[0]]);\n            case \"pow\":\n              return new OperatorNode('^', 'pow', expr.args);\n            case \"log\":\n              if(expr.args.length === 2) {\n                return new OperatorNode('/', 'divide', [\n                  new FunctionNode('log', [expr.args[0].map(helper)]),\n                  new FunctionNode('log', [expr.args[1].map(helper)])\n                ]);\n              } else {\n                break;\n              }\n            default:\n              break;\n          }\n        }\n        return expr.map(helper);\n      }\n    }\n\n    function removeDivision(expr) {\n      return expr.transform(function(node) {\n        if(!context.isConstant(node) && node.type === 'OperatorNode' && node.op === '/') {\n          return new OperatorNode('*', 'multiply', [\n            node.args[0],\n            new OperatorNode('^', 'pow', [\n              node.args[1],\n              new ConstantNode(-1)\n            ])\n          ]);\n        } else {\n          return node;\n        }\n      });\n    }\n  }\n\n  /**\n   * Gets the numerical value of the given node if possible, othewise returns undefined.\n   * TODO: does this work with BigNumber / Fractions / etc.\n   */\n  function getNumericValue(expr) {\n    var simplified = simplifyConstant(expr);\n    return toNumber(simplified);\n\n    function toNumber(expr) {\n      if(expr.type === 'OperatorNode' && expr.op === '-' && expr.args.length === 1) {\n        // Unary minus\n        var num = toNumber(expr.args[0]);\n        return num === undefined ? undefined : -num;\n      } else if(expr.type === 'ConstantNode' && (!expr.valueType || expr.valueType === 'number')) {\n        return +expr.value;\n      } else {\n        return undefined;\n      }\n    }\n  }\n\n  /**\n   * @name IntegrationRule\n   * @function\n   * @param {Node} expr The expression that is being integrated.\n   * @param {IntegrationContext} context The integration context.\n   * @param {function(expr: Node, context: IntegrationContext, ?ruleName: string)} subIntegral\n   *        Callback that attempts to integrate the given expression recursively.\n   * @return {Node | undefined | null} Returns the integrated expression, or undefined\n   *         or null if unable to find integral.\n   */\n\n  /**\n   * The default rules for integration.\n   *\n   * @type {Array.<IntegrationRule>}\n   */\n  integral.rules = [\n    // Simplify constants in the integral\n    function(expr, context, subIntegral) {\n      var simplified = simplify.simplifyCore(expr, context);\n      if(!simplified.equals(expr)) {\n        return subIntegral(simplified, context, \"simplified expression\");\n      }\n    },\n\n    // Ignore parentheses\n    function(expr, context, subIntegral) {\n      if(expr.type === 'ParenthesisNode') {\n        var int = subIntegral(expr.content, context, \"parentheses removal\");\n        return int ? new ParenthesisNode(int) : null;\n      }\n    },\n\n    // integral(c, x) = c * x\n    function(expr, context) {\n      if(context.isConstant(expr)) {\n        return new OperatorNode('*', 'multiply', [\n          expr.clone(),\n          context.variable.clone()\n        ]);\n      }\n    },\n\n    // integral(+/- f(x), x) = +/- integral(f(x), x) and\n    // integral(f(x) +/- g(x), x) = integral(f(x), x) +/- integral(g(x), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === \"OperatorNode\" && (expr.op === '+' || expr.op === '-')) {\n        var childInts = expr.args.map(function(expr) {\n          return subIntegral(expr, context, \"sum rule\");\n        });\n\n        if(childInts.every(function(n) { return n; })) {\n          return new OperatorNode(expr.op, expr.fn, childInts);\n        }\n      }\n    },\n\n    // integral(f(x) * (g(x) * h(x)), x) = integral(f(x) * g(x) * h(x), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === \"OperatorNode\" && expr.op === \"*\") {\n        var factors = getFactors(expr);\n        if(factors.length > expr.args.length) {\n          return subIntegral(new OperatorNode('*', 'multiply', factors), context, \"product flattening\");\n        }\n      }\n\n      function getFactors(expr) {\n        if(expr.type === \"OperatorNode\" && expr.op === \"*\") {\n          return expr.args.reduce(function(factors, expr) {\n            return factors.concat(getFactors(expr));\n          }, []);\n        } else if (expr.type === \"ParenthesisNode\") {\n          return getFactors(expr.content)\n        } else {\n          return [expr];\n        }\n      }\n    },\n\n    // integral(x, x) = 1/2*x^2\n    function(expr, context) {\n      if(expr.type === \"SymbolNode\" && expr.name === context.variable.name) {\n        return new OperatorNode('*', 'multiply', [\n          new OperatorNode('/', 'divide', [\n            new ConstantNode(1),\n            new ConstantNode(2)\n          ]),\n          new OperatorNode('^', 'pow', [\n            expr.clone(),\n            new ConstantNode(2)\n          ])\n        ]);\n      }\n    },\n\n    // integral(c*f(x), x) = c*integral(f(x), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === \"OperatorNode\" && expr.op === '*') {\n        var constantFactors = [];\n        var nonConstantFactors = [];\n        expr.args.forEach(function(expr) {\n          if(context.isConstant(expr)) {\n            constantFactors.push(expr);\n          } else {\n            nonConstantFactors.push(expr);\n          }\n        });\n\n        if(constantFactors.length !== 0) {\n          var constantNode = factorsToNode(constantFactors);\n          var nonConstantNode = factorsToNode(nonConstantFactors);\n\n          var nonConstantIntegral = subIntegral(nonConstantNode, context, \"multiplication by constant\");\n          if(nonConstantIntegral) {\n            return new OperatorNode('*', 'multiply', [constantNode, nonConstantIntegral]);\n          }\n        }\n\n        function factorsToNode(factors) {\n          if(factors.length === 1) {\n            return factors[0];\n          } else {\n            return new OperatorNode('*', 'multiply', factors);\n          }\n        }\n      }\n    },\n\n    // integral(x^c, x) = 1/(c+1) * x^(c+1) and integral(x^(-1)) = log(x)\n    function(expr, context) {\n      if(expr.type === \"OperatorNode\" && expr.op === '^' && expr.args[0].equals(context.variable) && context.isConstant(expr.args[1])) {\n        // Simplify Exponent if constant\n        var exponentValue = getNumericValue(expr.args[1]);\n        if(exponentValue === -1) {\n          return new FunctionNode('log', [\n            new FunctionNode('abs', [\n              context.variable.clone()\n            ])\n          ]);\n        } else {\n          return new OperatorNode('*', 'multiply', [\n            new OperatorNode('/', 'divide', [\n              new ConstantNode(1),\n              new OperatorNode('+', 'add', [\n                expr.args[1].clone(),\n                new ConstantNode(1)\n              ])\n            ]),\n            new OperatorNode('^', 'pow', [\n              expr.args[0].clone(),\n              new OperatorNode('+', 'add', [\n                expr.args[1].clone(),\n                new ConstantNode(1)\n              ])\n            ])\n          ]);\n        }\n      }\n    },\n\n    // integral(c^x, x) = c^x / log(c)\n    function(expr, context) {\n      if(expr.type === 'OperatorNode' && expr.op === '^') {\n        if(context.isConstant(expr.args[0]) && expr.args[1].equals(context.variable)) {\n          return new OperatorNode('/', 'divide', [\n            expr,\n            new FunctionNode('log', [expr.args[0]])\n          ]);\n        }\n      }\n    },\n\n    // integral(f(x)^g(x) * f(x)^h(x), x) = integral(f(x)^(g(x)+h(x)), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === \"OperatorNode\" && expr.op === '*') {\n        var argsAsPower = expr.args.map(getExprInPowerForm);\n\n        // Collect common bases (this is O(n^2) worst case)\n        var reducedArgs = argsAsPower.reduce(function(acc, exprPower) {\n          for(var i = 0; i < acc.length; i++) {\n            if(acc[i].base.equals(exprPower.base)) {\n              acc[i].power = new OperatorNode('+', 'add', [\n                acc[i].power,\n                exprPower.power\n              ]);\n              return acc;\n            }\n          }\n\n          // Did not share a common base with any other factor so far\n          acc.push(exprPower);\n          return acc;\n        }, []);\n\n        if(reducedArgs.length < expr.args.length) {\n          // We combined some things\n          var reducedExpr = powerFactorsToNode(reducedArgs);\n\n          return subIntegral(reducedExpr, context, \"combining powers\");\n        }\n      }\n\n      function getExprInPowerForm(expr) {\n        if(expr.type === \"OperatorNode\" && expr.op === '^') {\n          return {\n            base: expr.args[0],\n            power: expr.args[1]\n          };\n        } else {\n          return {\n            base: expr,\n            power: new ConstantNode(1)\n          };\n        }\n      }\n\n      function powerFactorsToNode(factors) {\n        if(factors.length === 1) {\n          return powerToNode(factors[0]);\n        } else {\n          return new OperatorNode('*', 'multiply', factors.map(powerToNode));\n        }\n\n        function powerToNode(powerExpr) {\n          return new OperatorNode('^', 'pow', [powerExpr.base, powerExpr.power]);\n        }\n      }\n    },\n\n    // integral((f(x) * g(x))^h(x), x) = integral(f(x)^h(x) * g(x)^h(x))\n    function(expr, context, subIntegral) {\n      if(expr.type === 'OperatorNode' && expr.op === '^') {\n        var base = expr.args[0];\n        var exponent = expr.args[1];\n        if(base.type === 'OperatorNode' && base.op === '*') {\n          return subIntegral(new OperatorNode('*', 'multiply', base.args.map(function(baseChild) {\n            return new OperatorNode('^', 'pow', [baseChild, exponent]);\n          })), context, \"distributing power\");\n        }\n      }\n    },\n\n    // integral((f(x) ^ g(x)) ^ h(x), x) = integral(f(x) ^ (g(x) * h(x)), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === 'OperatorNode' && expr.op === '^') {\n        if(expr.args[0].type === 'OperatorNode' && expr.args[0].op === '^') {\n          return subIntegral(new OperatorNode('^', 'pow', [\n            expr.args[0].args[0],\n            new OperatorNode('*', 'multiply', [\n              expr.args[0].args[1],\n              expr.args[1]\n            ])\n          ]), context, 'removing double exponential');\n        }\n      }\n    },\n\n    // integral(f(x) * +/-g(x), x) = +/-integral(f(x) * g(x), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === \"OperatorNode\" && expr.op === '*') {\n        var wasChange = false;\n        var isTotalPositive = true;\n        var processedArgs = [];\n        expr.args.forEach(function(expr) {\n          if(expr.type === \"OperatorNode\" && expr.args.length === 1 && (expr.op === '+' || expr.op === '-')) {\n            wasChange = true;\n            isTotalPositive = isTotalPositive ^ (expr.op === '-');\n            processedArgs.push(expr.args[0]);\n          } else {\n            processedArgs.push(expr);\n          }\n        });\n\n        if(wasChange) {\n          var int = subIntegral(new OperatorNode('*', 'multiply', processedArgs), context, \"removing unary +/- from factors\");\n          if(int) {\n            return isTotalPositive ? int : new OperatorNode('-', 'unaryMinus', [int]);\n          }\n        }\n      }\n    },\n\n    // integral(f(x) * (g(x) + h(x)), x) = integral(f(x) * g(x) + f(x) * h(x), x)\n    function(expr, context, subIntegral) {\n      if(expr.type === \"OperatorNode\" && expr.op === '*') {\n        var sumNode = null;\n        var otherFactors = null;\n        for(var i = 0; i < expr.args.length; i++) {\n          if(expr.args[i].type === \"OperatorNode\" && (expr.args[i].op === '+' || expr.args[i].op === '-'))  {\n            sumNode = expr.args[i];\n            otherFactors = expr.args.filter(function(expr, index) { return index !== i; });\n            break;\n          }\n        }\n\n        if(sumNode !== null) {\n          var newTerms = sumNode.args.map(function(term) {\n            return new OperatorNode('*', 'multiply', otherFactors.concat([term]));\n          });\n          return subIntegral(new OperatorNode(sumNode.op, sumNode.fn, newTerms), context, \"product distribution\");\n        }\n      }\n    },\n\n    // integral(f(a*x + b), x) = 1/a * F(a*x + b) where F(u) = integral(f(u), u)\n    // We also only handle the case where u shows up only once in f(u)\n    function(expr, context, subIntegral) {\n      var createIntegralWrapper = null;\n\n      var uniqueParent = getParentOfUniqueVariable(expr);\n      if(uniqueParent !== null && uniqueParent.type === \"OperatorNode\") {\n        if(uniqueParent.op === '+' || uniqueParent.op === '-') {\n          if(uniqueParent.args.length === 1) {\n            // unary + or -\n            createIntegralWrapper = function(int) {\n              return new OperatorNode(uniqueParent.op, uniqueParent.fn, [int]);\n            }\n          } else {\n            createIntegralWrapper = function(int) {\n              return int;\n            }\n          }\n        } else if(uniqueParent.op === '*') {\n          createIntegralWrapper = function(int) {\n            return new OperatorNode('/', 'divide', [int,\n              // \"remove\" the variable of integration\n              replaceNodeInTree(uniqueParent, context.variable, new ConstantNode(1))\n            ]);\n          };\n        }\n\n        if(createIntegralWrapper !== null) {\n          var preIntegral = replaceNodeInTree(expr, uniqueParent, context.variable.clone());\n          var int = subIntegral(preIntegral, context, \"linear substitution\");\n          if(int) {\n            var backSubstituted = replaceNodeInTree(int, context.variable, uniqueParent);\n            return createIntegralWrapper(backSubstituted);\n          }\n        }\n      }\n\n      function replaceNodeInTree(expr, node, replacement) {\n        return replaceHelper(expr);\n\n        function replaceHelper(curNode) {\n          return node.equals(curNode) ? replacement : curNode.map(replaceHelper);\n        }\n      }\n\n      function getParentOfUniqueVariable(expr) {\n        return helper(expr, null);\n\n        function helper(expr, parent) {\n          if(context.isConstant(expr)) {\n            return null;\n          } else if(expr.type === \"SymbolNode\" && expr.name === context.variable.name) {\n            return parent;\n          } else {\n            var nonConstantChildren = [];\n            expr.forEach(function(child) {\n              if(!context.isConstant(child)) {\n                nonConstantChildren.push(child);\n              }\n            });\n\n            if(nonConstantChildren.length === 1) {\n              return helper(nonConstantChildren[0], expr);\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n    },\n\n    // integral(f(x)^c [* g(x)], x) = integral(f(x) * f(x)^(c-1) [* g(x)], x)\n    // However, we only expand for c<=10 to save computational resources\n    function(expr, context, subIntegral) {\n      var MaxExponentExpanded = 10;\n\n      if(expr.type === 'OperatorNode' && expr.op === '^') {\n        var multipliedOut = tryMultiplyOut(expr);\n        if(multipliedOut) {\n          var int = subIntegral(multipliedOut, context, \"reducing power\");\n          if(int) {\n            return int;\n          }\n        }\n      } else if(expr.type === 'OperatorNode' && expr.op === '*') {\n        for(var i = 0; i < expr.args.length; i++) {\n          var multipliedOutChild = tryMultiplyOut(expr.args[i]);\n          if(multipliedOutChild) {\n            var int = subIntegral(new OperatorNode('*', 'multiply', multipliedOutChild.args.concat(\n              expr.args.slice(0, i),\n              expr.args.slice(i+1)\n            )), context, \"reducing power\");\n\n            if(int) {\n              return int;\n            }\n          }\n        }\n      }\n\n      //\n      function tryMultiplyOut(expr) {\n        if(expr.type === 'OperatorNode' && expr.op === '^' && !context.isConstant(expr.args[0])) {\n          var exponentValue = getNumericValue(expr.args[1]);\n          if(Number.isInteger(exponentValue) && exponentValue > 1 && exponentValue <= MaxExponentExpanded) {\n            return new OperatorNode('*', 'multiply', [\n              expr.args[0],\n              exponentValue === 2 ? expr.args[0] : new OperatorNode('^', 'pow', [\n                expr.args[0],\n                new ConstantNode(exponentValue-1)\n              ])\n            ]);\n          }\n        }\n\n        return null;\n      }\n    },\n\n    // integral(log(x), x) = x*log(x) - x\n    function(expr, context, subIntegral) {\n      if(expr.type === 'FunctionNode' && expr.name === 'log' && expr.args.length === 1) {\n        if(expr.args.length === 1 && expr.args[0].equals(context.variable)) {\n          return new OperatorNode('-', 'subtract', [\n            new OperatorNode('*', 'multiply', [\n              context.variable,\n              new FunctionNode('log', [context.variable])\n            ]),\n            context.variable\n          ]);\n        }\n      }\n    },\n\n    // integral(sin(x), x) = -cos(x)\n    // integral(cos(x), x) = sin(x)\n    // integral(tan(x), x) = log(abs(sec(x)))\n    // integral(sec(x), x) = log(abs(sec(x) + tan(x)))\n    // integral(csc(x), x) = log(abs(csc(x) - cot(x)))\n    // integral(cot(x), x) = log(abs(sin(x)))\n    function(expr, context, subIntegral) {\n      if(expr.type === 'FunctionNode' && expr.args[0].equals(context.variable)) {\n        switch(expr.name) {\n          case \"sin\":\n            return new OperatorNode('-', 'unaryMinus', [\n              new FunctionNode(\"cos\", [context.variable])\n            ]);\n          case \"cos\":\n            return new FunctionNode(\"sin\", [context.variable]);\n          case \"tan\":\n            //log(abs(sec(x)))\n            return new FunctionNode('log', [\n              new FunctionNode('abs', [\n                new FunctionNode('sec', [context.variable])\n              ])\n            ]);\n          case \"sec\":\n            //log(abs(sec(x) + tan(x)))\n            return new FunctionNode('log', [\n              new FunctionNode('abs', [\n                new OperatorNode('+', 'add', [\n                  new FunctionNode('sec', [context.variable]),\n                  new FunctionNode('tan', [context.variable])\n                ])\n              ])\n            ]);\n          case \"csc\":\n            //log(abs(sec(x) + tan(x)))\n            return new FunctionNode('log', [\n              new FunctionNode('abs', [\n                new OperatorNode('-', 'subtract', [\n                  new FunctionNode('csc', [context.variable]),\n                  new FunctionNode('cot', [context.variable])\n                ])\n              ])\n            ]);\n          case \"cot\":\n            //log(abs(sec(x) + tan(x)))\n            return new FunctionNode('log', [\n              new FunctionNode('abs', [\n                new FunctionNode('sin', [context.variable])\n              ])\n            ]);\n          default:\n            return null;\n        }\n      }\n    }\n  ];\n\n  /**\n   * Helper function that runs the main loop for the integrator. It scans over the\n   * rules until one of them produces an integral or until no more rules are left.\n   *\n   * @param {Node} expr The expression to be integrated.\n   * @param {IntegrationContext}\n   */\n  function _integral(expr, context, lastRuleComment) {\n    var exprString = expr.toString({\n      parenthesis: 'all',\n      handler: function(node, options) {\n        if(node.type === 'ParenthesisNode') {\n          return '(' + node.content.toString(options) + ')';\n        }\n      }\n    });\n\n    var debugComment = lastRuleComment ? lastRuleComment + \": \" : \"\";\n    debugComment += \"find integral of \" + exprString + \"  d\" + context.variable.name;\n    context.printDebug(debugComment);\n    context.debugIndent++;\n\n    // Check if we already tried to integrate this expression\n    if(context.subIntegral[exprString] !== undefined) {\n      // This could be null, indicating that we couldn't find an integral for\n      // it (or we are currenly working on it a few levels of recursion up!)\n      context.printDebug(\"Precomputed: \" + context.subIntegral[exprString]);\n      context.debugIndent--;\n      return context.subIntegral[exprString];\n    }\n\n    // Remember that we are working on this integral, just haven't found a\n    // solution yet!\n    context.subIntegral[exprString] = null;\n\n    for(var i = 0; i < context.rules.length; i++) {\n      var result = context.rules[i](expr, context, _integral);\n      if(result !== undefined && result !== null) {\n        // Remember this solution!\n        context.subIntegral[exprString] = result;\n\n        context.printDebug(\"Computed: \" + result.toString({parenthesis: 'all'}));\n        context.debugIndent--;\n        return result;\n      }\n    }\n\n    // We couldn't find a solution :(\n    context.printDebug(\"No integral found\");\n    context.debugIndent--;\n    return null;\n  }\n\n  return integral;\n};\n\nexports.name = 'integral';\nexports.factory = factory;\n","'use strict';\n\nvar keywords = require('../keywords');\nvar stringify = require('../../utils/string').stringify;\nvar escape = require('../../utils/string').escape;\nvar map = require('../../utils/array').map;\nvar join = require('../../utils/array').join;\nvar latex = require('../../utils/latex');\nvar operators = require('../operators');\nvar setSafeProperty = require('../../utils/customs').setSafeProperty;\nvar getUniqueArgumentName = require('./utils/getUniqueArgumentName');\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    // validate input\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params))  throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!type.isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (name in keywords) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any'\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {FunctionAssignmentNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileFunctionAssignmentNode(node, defs, args) {\n    if (!(node instanceof FunctionAssignmentNode)) {\n      throw new TypeError('No valid FunctionAssignmentNode')\n    }\n\n    defs.typed = typed;\n    defs.setSafeProperty = setSafeProperty;\n\n    // validate params\n    // FIXME: rename parameters to safe, internal names\n\n    // we extend the original args and add the args to the child object\n    // and create a mapping from the unsafe param name to a safe, internal one\n    var childArgs = Object.create(args);\n    var jsParams = map(node.params, function (param) {\n      childArgs[param] = getUniqueArgumentName(childArgs);\n      return childArgs[param];\n    });\n\n    // compile the function expression with the child args\n    var jsExpr = compile(node.expr, defs, childArgs);\n    var jsName = stringify(node.name);\n\n    return 'setSafeProperty(scope, ' + jsName + ', ' +\n        '  (function () {' +\n        '    var fn = typed(' + jsName + ', {' +\n        '      ' + stringify(join(node.types, ',')) + ': function (' + join(jsParams, ',') + ') {' +\n        '        return ' + jsExpr + '' +\n        '      }' +\n        '    });' +\n        '    fn.syntax = ' + stringify(node.name + '(' + join(node.params, ', ') + ')') + ';' +\n        '    return fn;' +\n        '  })())';\n  }\n\n  // register the compile function\n  register(FunctionAssignmentNode.prototype.type, compileFunctionAssignmentNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n  function needParenthesis(node, parenthesis) {\n    var precedence = operators.getPrecedence(node, parenthesis);\n    var exprPrecedence = operators.getPrecedence(node.expr, parenthesis);\n\n    return (parenthesis === 'all')\n      || ((exprPrecedence !== null) && (exprPrecedence <= precedence));\n  }\n\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n   FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n\tvar params = [];\n\tfor (var i=0; i<this.params.length; i++)\t{\n\t  params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n\t}\n    var expr = this.expr.toHTML(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '\\\\left(' + expr + '\\\\right)';\n    }\n\n    return '\\\\mathrm{' + this.name\n        + '}\\\\left(' + this.params.map(latex.toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}\nexports.name = 'FunctionAssignmentNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\n/**\n * Create a syntax error with the message:\n *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'\n * @param {string} fn     Function name\n * @param {number} count  Actual argument count\n * @param {number} min    Minimum required argument count\n * @param {number} [max]  Maximum required argument count\n * @extends Error\n */\nfunction ArgumentsError(fn, count, min, max) {\n  if (!(this instanceof ArgumentsError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.fn = fn;\n  this.count = count;\n  this.min = min;\n  this.max = max;\n\n  this.message = 'Wrong number of arguments in function ' + fn +\n      ' (' + count + ' provided, ' +\n      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';\n\n  this.stack = (new Error()).stack;\n}\n\nArgumentsError.prototype = new Error();\nArgumentsError.prototype.constructor = Error;\nArgumentsError.prototype.name = 'ArgumentsError';\nArgumentsError.prototype.isArgumentsError = true;\n\nmodule.exports = ArgumentsError;\n","'use strict';\n\nvar errorTransform = require('../../transform/error.transform').transform;\nvar getSafeProperty = require('../../../utils/customs').getSafeProperty;\n\nfunction factory (type, config, load, typed) {\n  var subset = load(require('../../../function/matrix/subset'));\n\n  /**\n   * Retrieve part of an object:\n   *\n   * - Retrieve a property from an object\n   * - Retrieve a part of a string\n   * - Retrieve a matrix subset\n   *\n   * @param {Object | Array | Matrix | string} object\n   * @param {Index} index\n   * @return {Object | Array | Matrix | string} Returns the subset\n   */\n  return function access(object, index) {\n    try {\n      if (Array.isArray(object)) {\n        return subset(object, index);\n      }\n      else if (object && typeof object.subset === 'function') { // Matrix\n        return object.subset(index);\n      }\n      else if (typeof object === 'string') {\n        // TODO: move getStringSubset into a separate util file, use that\n        return subset(object, index);\n      }\n      else if (typeof object === 'object') {\n        if (!index.isObjectProperty()) {\n          throw new TypeError('Cannot apply a numeric index as object property');\n        }\n\n        return getSafeProperty(object, index.getObjectProperty());\n      }\n      else {\n        throw new TypeError('Cannot apply index: unsupported type of object');\n      }\n    }\n    catch (err) {\n      throw errorTransform(err);\n    }\n  }\n}\n\nexports.factory = factory;\n","'use strict';\n\nvar map = require('../../utils/array').map;\nvar join = require('../../utils/array').join;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || [];\n\n    // validate input\n    if (!Array.isArray(this.items) || !this.items.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n\n    // TODO: deprecated since v3, remove some day\n    var deprecated = function () {\n      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');\n    };\n    Object.defineProperty(this, 'nodes', { get: deprecated, set: deprecated });\n  }\n\n  ArrayNode.prototype = new Node();\n\n  ArrayNode.prototype.type = 'ArrayNode';\n\n  ArrayNode.prototype.isArrayNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {ArrayNode} node  Node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @private\n   */\n  function compileArrayNode(node, defs, args) {\n    if (!(node instanceof ArrayNode)) {\n      throw new TypeError('No valid ArrayNode')\n    }\n\n    var asMatrix = (defs.math.config().matrix !== 'Array');\n\n    var items = map(node.items, function (item) {\n      return compile(item, defs, args);\n    });\n\n    return (asMatrix ? 'math.matrix([' : '[') +\n        join(items, ',') +\n        (asMatrix ? '])' : ']');\n  }\n\n  // register the compile function\n  register(ArrayNode.prototype.type, compileArrayNode);\n\n      /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n    return new ArrayNode(items);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n  ArrayNode.prototype.clone = function() {\n    return new ArrayNode(this.items.slice(0));\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ArrayNode.prototype._toString = function(options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ArrayNode.prototype.toHTML = function(options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ArrayNode.prototype._toTex = function(options) {\n    var s = '\\\\begin{bmatrix}';\n\n    this.items.forEach(function(node) {\n      if (node.items) {\n        s += node.items.map(function(childNode) {\n          return childNode.toTex(options);\n        }).join('&');\n      }\n      else {\n        s += node.toTex(options);\n      }\n\n      // new line\n      s += '\\\\\\\\';\n    });\n    s += '\\\\end{bmatrix}';\n    return s;\n  };\n\n  return ArrayNode;\n}\n\nexports.name = 'ArrayNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\nfunction factory (type, config, load, typed) {\n  /**\n   * A ResultSet contains a list or results\n   * @class ResultSet\n   * @param {Array} entries\n   * @constructor ResultSet\n   */\n  function ResultSet(entries) {\n    if (!(this instanceof ResultSet)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.entries = entries || [];\n  }\n\n  /**\n   * Attach type information\n   */\n  ResultSet.prototype.type = 'ResultSet';\n  ResultSet.prototype.isResultSet = true;\n\n  /**\n   * Returns the array with results hold by this ResultSet\n   * @memberof ResultSet\n   * @returns {Array} entries\n   */\n  ResultSet.prototype.valueOf = function () {\n    return this.entries;\n  };\n\n  /**\n   * Returns the stringified results of the ResultSet\n   * @memberof ResultSet\n   * @returns {string} string\n   */\n  ResultSet.prototype.toString = function () {\n    return '[' + this.entries.join(', ') + ']';\n  };\n\n  /**\n   * Get a JSON representation of the ResultSet\n   * @memberof ResultSet\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"ResultSet\", \"entries\": [...]}`\n   */\n  ResultSet.prototype.toJSON = function () {\n    return {\n      mathjs: 'ResultSet',\n      entries: this.entries\n    };\n  };\n\n  /**\n   * Instantiate a ResultSet from a JSON object\n   * @memberof ResultSet\n   * @param {Object} json  A JSON object structured as:\n   *                       `{\"mathjs\": \"ResultSet\", \"entries\": [...]}`\n   * @return {ResultSet}\n   */\n  ResultSet.fromJSON = function (json) {\n    return new ResultSet(json.entries);\n  };\n\n  return ResultSet;\n}\n\nexports.name = 'ResultSet';\nexports.path = 'type';\nexports.factory = factory;\n","\"use strict\";\n\n// Map the characters to escape to their escaped values. The list is derived\n// from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar defaultEscapes = {\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"\\\\\": \"\\\\textbackslash{}\",\n  \"#\": \"\\\\#\",\n  $: \"\\\\$\",\n  \"%\": \"\\\\%\",\n  \"&\": \"\\\\&\",\n  \"^\": \"\\\\textasciicircum{}\",\n  _: \"\\\\_\",\n  \"~\": \"\\\\textasciitilde{}\"\n};\nvar formatEscapes = {\n  \"\\u2013\": \"\\\\--\",\n  \"\\u2014\": \"\\\\---\",\n  \" \": \"~\",\n  \"\\t\": \"\\\\qquad{}\",\n  \"\\r\\n\": \"\\\\newline{}\",\n  \"\\n\": \"\\\\newline{}\"\n};\n\nvar defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {\n  return _extends({}, defaultEscapes, formatEscapes);\n};\n\n/**\n * Escape a string to be used in LaTeX documents.\n * @param {string} str the string to be escaped.\n * @param {boolean} params.preserveFormatting whether formatting escapes should\n *  be performed (default: false).\n * @param {function} params.escapeMapFn the function to modify the escape maps.\n * @return {string} the escaped string, ready to be used in LaTeX.\n */\nmodule.exports = function (str) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$preserveFormatti = _ref.preserveFormatting,\n      preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,\n      _ref$escapeMapFn = _ref.escapeMapFn,\n      escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;\n\n  var runningStr = String(str);\n  var result = \"\";\n\n  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});\n  var escapeKeys = Object.keys(escapes); // as it is reused later on\n\n  // Algorithm: Go through the string character by character, if it matches\n  // with one of the special characters then we'll replace it with the escaped\n  // version.\n\n  var _loop = function _loop() {\n    var specialCharFound = false;\n    escapeKeys.forEach(function (key, index) {\n      if (specialCharFound) {\n        return;\n      }\n      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {\n        result += escapes[escapeKeys[index]];\n        runningStr = runningStr.slice(key.length, runningStr.length);\n        specialCharFound = true;\n      }\n    });\n    if (!specialCharFound) {\n      result += runningStr.slice(0, 1);\n      runningStr = runningStr.slice(1, runningStr.length);\n    }\n  };\n\n  while (runningStr) {\n    _loop();\n  }\n  return result;\n};","'use strict';\n\nvar operators = require('../operators');\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    // validate inputs\n    if (!type.isNode(start)) throw new TypeError('Node expected');\n    if (!type.isNode(end)) throw new TypeError('Node expected');\n    if (step && !type.isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n\n    this.start = start;         // included lower-bound\n    this.end = end;           // included upper-bound\n    this.step = step || null;  // optional step\n  }\n\n  RangeNode.prototype = new Node();\n\n  RangeNode.prototype.type = 'RangeNode';\n\n  RangeNode.prototype.isRangeNode = true;\n\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return type.isSymbolNode(node) && (node.name === 'end');\n    });\n\n    return endSymbols.length > 0;\n  };\n\n  /**\n   * Compile the node to javascript code\n   *\n   * When the range has a symbol `end` defined, the RangeNode requires\n   * a variable `end` to be defined in the current closure, which must contain\n   * the length of the of the matrix that's being handled in the range's\n   * dimension. To check whether the `end` variable is needed, call\n   * RangeNode.needsEnd().\n   *\n   * @param {RangeNode} node  The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileRangeNode(node, defs, args) {\n    if (!(node instanceof RangeNode)) {\n      throw new TypeError('No valid RangeNode')\n    }\n\n    return 'math.range(' +\n        compile(node.start, defs, args) + ', ' +\n        compile(node.end, defs, args) +\n        (node.step ? (', ' + compile(node.step, defs, args)) : '') +\n        ')';\n  }\n\n  // register the compile function\n  register(RangeNode.prototype.type, compileRangeNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(\n        this._ifNode(callback(this.start, 'start', this)),\n        this._ifNode(callback(this.end, 'end', this)),\n        this.step && this._ifNode(callback(this.step, 'step', this))\n    );\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = operators.getPrecedence(node, parenthesis);\n    var parens = {};\n\n    var startPrecedence = operators.getPrecedence(node.start, parenthesis);\n    parens.start = ((startPrecedence !== null) && (startPrecedence <= precedence))\n      || (parenthesis === 'all');\n\n    if (node.step) {\n      var stepPrecedence = operators.getPrecedence(node.step, parenthesis);\n      parens.step = ((stepPrecedence !== null) && (stepPrecedence <= precedence))\n        || (parenthesis === 'all');\n    }\n\n    var endPrecedence = operators.getPrecedence(node.end, parenthesis);\n    parens.end = ((endPrecedence !== null) && (endPrecedence <= precedence))\n      || (parenthesis === 'all');\n\n    return parens;\n  }\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n\n    //format string as start:step:stop\n    var str;\n\n    var start = this.start.toString(options);\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n    str += ':' + end;\n\n    return str;\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n\n    //format string as start:step:stop\n    var str;\n\n    var start = this.start.toHTML(options);\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n\n    return str;\n  };\n\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n\n    var str = this.start.toTex(options);\n    if (parens.start) {\n      str = '\\\\left(' + str + '\\\\right)';\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n      if (parens.step) {\n        step = '\\\\left(' + step + '\\\\right)';\n      }\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n    if (parens.end) {\n      end = '\\\\left(' + end + '\\\\right)';\n    }\n    str += ':' + end;\n\n    return str;\n  };\n\n  return RangeNode;\n}\n\nexports.name = 'RangeNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\nmodule.exports = function deepMap(array, callback, skipZeros) {\n  if (array && (typeof array.map === 'function')) {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  }\n  else {\n    return callback(array);\n  }\n};\n","'use strict'\n\n//list of identifiers of nodes in order of their precedence\n//also contains information about left/right associativity\n//and which other operator the operator is associative with\n//Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators \n// are right associative\n//\n//It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's! \n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nvar properties = [\n  { //assignment\n    'AssignmentNode': {},\n    'FunctionAssignmentNode': {}\n  },\n  { //conditional expression\n    'ConditionalNode': {\n      latexLeftParens: false,\n      latexRightParens: false,\n      latexParens: false\n      //conditionals don't need parentheses in LaTeX because\n      //they are 2 dimensional\n    }\n  },\n  { //logical or\n    'OperatorNode:or': {\n      associativity: 'left',\n      associativeWith: []\n    }\n\n  },\n  { //logical xor\n    'OperatorNode:xor': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //logical and\n    'OperatorNode:and': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //bitwise or\n    'OperatorNode:bitOr': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //bitwise xor\n    'OperatorNode:bitXor': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //bitwise and\n    'OperatorNode:bitAnd': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //relational operators\n    'OperatorNode:equal': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:unequal': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:smaller': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:larger': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:smallerEq': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:largerEq': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //bitshift operators\n    'OperatorNode:leftShift': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:rightArithShift': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:rightLogShift': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //unit conversion\n    'OperatorNode:to': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //range\n    'RangeNode': {}\n  },\n  { //addition, subtraction\n    'OperatorNode:add': {\n      associativity: 'left',\n      associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n    },\n    'OperatorNode:subtract': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //multiply, divide, modulus\n    'OperatorNode:multiply': {\n      associativity: 'left',\n      associativeWith: [\n        'OperatorNode:multiply',\n        'OperatorNode:divide',\n        'Operator:dotMultiply',\n        'Operator:dotDivide'\n      ]\n    },\n    'OperatorNode:divide': {\n      associativity: 'left',\n      associativeWith: [],\n      latexLeftParens: false,\n      latexRightParens: false,\n      latexParens: false\n      //fractions don't require parentheses because\n      //they're 2 dimensional, so parens aren't needed\n      //in LaTeX\n    },\n    'OperatorNode:dotMultiply': {\n      associativity: 'left',\n      associativeWith: [\n        'OperatorNode:multiply',\n        'OperatorNode:divide',\n        'OperatorNode:dotMultiply',\n        'OperatorNode:doDivide'\n      ]\n    },\n    'OperatorNode:dotDivide': {\n      associativity: 'left',\n      associativeWith: []\n    },\n    'OperatorNode:mod': {\n      associativity: 'left',\n      associativeWith: []\n    }\n  },\n  { //unary prefix operators\n    'OperatorNode:unaryPlus': {\n      associativity: 'right'\n    },\n    'OperatorNode:unaryMinus': {\n      associativity: 'right'\n    },\n    'OperatorNode:bitNot': {\n      associativity: 'right'\n    },\n    'OperatorNode:not': {\n      associativity: 'right'\n    }\n  },\n  { //exponentiation\n    'OperatorNode:pow': {\n      associativity: 'right',\n      associativeWith: [],\n      latexRightParens: false\n      //the exponent doesn't need parentheses in\n      //LaTeX because it's 2 dimensional\n      //(it's on top)\n    },\n    'OperatorNode:dotPow': {\n      associativity: 'right',\n      associativeWith: []\n    }\n  },\n  { //factorial\n    'OperatorNode:factorial': {\n      associativity: 'left'\n    }\n  },\n  { //matrix transpose\n    'OperatorNode:transpose': {\n      associativity: 'left'\n    }\n  }\n];\n\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node}\n * @param {string} parenthesis\n * @return {number|null}\n */\nfunction getPrecedence (_node, parenthesis) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    //ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node}\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\nfunction getAssociativity (_node, parenthesis) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    //ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n  if (index === null) {\n    //node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifier];\n\n  if (property.hasOwnProperty('associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n    if (property.associativity === 'right') {\n      return 'right';\n    }\n    //associativity is invalid\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\''\n                + property.associativity + '\\'.');\n  }\n\n  //associativity is undefined\n  return null;\n}\n\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {bool|null}\n */\nfunction isAssociativeWith (nodeA, nodeB, parenthesis) {\n  var a = nodeA;\n  var b = nodeB;\n  if (parenthesis !== 'keep') {\n    //ParenthesisNodes are only ignored when not in 'keep' mode\n    var a = nodeA.getContent();\n    var b = nodeB.getContent();\n  }\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n  if (index === null) {\n    //node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifierA];\n\n  if (property.hasOwnProperty('associativeWith')\n      && (property.associativeWith instanceof Array)) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  //associativeWith is not defined\n  return null;\n}\n\nmodule.exports.properties = properties;\nmodule.exports.getPrecedence = getPrecedence;\nmodule.exports.getAssociativity = getAssociativity;\nmodule.exports.isAssociativeWith = isAssociativeWith;\n","'use strict';\n\n/**\n * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue\n */\n\n/**\n * Test whether value is a number\n * @param {*} value\n * @return {boolean} isNumber\n */\nexports.isNumber = function(value) {\n  return typeof value === 'number';\n};\n\n/**\n * Check if a number is integer\n * @param {number | boolean} value\n * @return {boolean} isInteger\n */\nexports.isInteger = function(value) {\n  return isFinite(value)\n      ? (value == Math.round(value))\n      : false;\n  // Note: we use ==, not ===, as we can have Booleans as well\n};\n\n/**\n * Calculate the sign of a number\n * @param {number} x\n * @returns {*}\n */\nexports.sign = Math.sign || function(x) {\n  if (x > 0) {\n    return 1;\n  }\n  else if (x < 0) {\n    return -1;\n  }\n  else {\n    return 0;\n  }\n};\n\n/**\n * Convert a number to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'engineering'    Always use engineering notation.\n *                                          For example '123.4e+0' and '14.0e+6'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lower` and `upper` bounds, and uses\n *                                          exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential' and\n *                                          'auto', `precision` defines the total\n *                                          number of significant digits returned\n *                                          and is undefined by default.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point, and is 0 by default.\n *                     {Object} exponential An object containing two parameters,\n *                                          {number} lower and {number} upper,\n *                                          used by notation 'auto' to determine\n *                                          when to return exponential notation.\n *                                          Default values are `lower=1e-3` and\n *                                          `upper=1e5`.\n *                                          Only applicable for notation `auto`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4);                                        // '6.4'\n *    format(1240000);                                    // '1.24e6'\n *    format(1/3);                                        // '0.3333333333333333'\n *    format(1/3, 3);                                     // '0.333'\n *    format(21385, 2);                                   // '21000'\n *    format(12.071, {notation: 'fixed'});                // '12'\n *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'\n *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'\n *    format(12345678, {notation: 'engineering'});        // '12.345678e+6'\n *\n * @param {number} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\nexports.format = function(value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  }\n\n  // handle special cases\n  if (value === Infinity) {\n    return 'Infinity';\n  }\n  else if (value === -Infinity) {\n    return '-Infinity';\n  }\n  else if (isNaN(value)) {\n    return 'NaN';\n  }\n\n  // default values for options\n  var notation = 'auto';\n  var precision = undefined;\n\n  if (options) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    }\n\n    // determine precision from options\n    if (exports.isNumber(options)) {\n      precision = options;\n    }\n    else if (options.precision) {\n      precision = options.precision;\n    }\n  }\n\n  // handle the various notations\n  switch (notation) {\n    case 'fixed':\n      return exports.toFixed(value, precision);\n\n    case 'exponential':\n      return exports.toExponential(value, precision);\n\n    case 'engineering':\n      return exports.toEngineering(value, precision);\n\n    case 'auto':\n      return exports\n          .toPrecision(value, precision, options && options.exponential)\n\n          // remove trailing zeros after the decimal point\n          .replace(/((\\.\\d*?)(0+))($|e)/, function () {\n            var digits = arguments[2];\n            var e = arguments[4];\n            return (digits !== '.') ? digits + e : e;\n          });\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' +\n          'Choose \"auto\", \"exponential\", or \"fixed\".');\n  }\n};\n\n/**\n * Split a number into sign, coefficients, and exponent\n * @param {number | string} value\n * @return {SplitValue}\n *              Returns an object containing sign, coefficients, and exponent\n */\nexports.splitNumber = function (value) {\n  // parse the input value\n  var match = String(value).toLowerCase().match(/^0*?(-?)(\\d+\\.?\\d*)(e([+-]?\\d+))?$/);\n  if (!match) {\n    throw new SyntaxError('Invalid number ' + value);\n  }\n\n  var sign         = match[1];\n  var digits       = match[2];\n  var exponent     = parseFloat(match[4] || '0');\n\n  var dot = digits.indexOf('.');\n  exponent += (dot !== -1) ? (dot - 1) : (digits.length - 1);\n\n  var coefficients = digits\n      .replace('.', '')  // remove the dot (must be removed before removing leading zeros)\n      .replace(/^0*/, function (zeros) {\n        // remove leading zeros, add their count to the exponent\n        exponent -= zeros.length;\n        return '';\n      })\n      .replace(/0*$/, '') // remove trailing zeros\n      .split('')\n      .map(function (d) {\n        return parseInt(d);\n      });\n\n  if (coefficients.length === 0) {\n    coefficients.push(0);\n    exponent++;\n  }\n\n  return {\n    sign: sign,\n    coefficients: coefficients,\n    exponent: exponent\n  };\n};\n\n\n/**\n * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'\n * @param {number | string} value\n * @param {number} [precision=0]        Optional number of decimals after the\n *                                      decimal point. Zero by default.\n */\nexports.toEngineering = function (value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n  \n  var rounded = exports.roundDigits(exports.splitNumber(value), precision);\n\n  var e = rounded.exponent;\n  var c = rounded.coefficients;\n\n  // find nearest lower multiple of 3 for exponent\n  var newExp = e % 3 === 0 ? e : (e < 0 ? (e - 3) - (e % 3) : e - (e % 3));\n\n  // concatenate coefficients with necessary zeros\n  var significandsDiff = e >= 0 ? e : Math.abs(newExp);\n\n  // add zeros if necessary (for ex: 1e+8)\n  if (c.length - 1 < significandsDiff) c = c.concat(zeros(significandsDiff - (c.length - 1)));\n\n  // find difference in exponents\n  var expDiff = Math.abs(e - newExp);\n\n  var decimalIdx = 1;\n\n  // push decimal index over by expDiff times\n  while (--expDiff >= 0) decimalIdx++;\n\n  // if all coefficient values are zero after the decimal point, don't add a decimal value.\n  // otherwise concat with the rest of the coefficients\n  var decimals = c.slice(decimalIdx).join('');\n  var decimalVal = decimals.match(/[1-9]/) ? ('.' + decimals) : '';\n\n  var str = c.slice(0, decimalIdx).join('') +\n      decimalVal +\n      'e' + (e >= 0 ? '+' : '') + newExp.toString();\n  return rounded.sign + str;\n};\n\n/**\n * Format a number with fixed notation.\n * @param {number | string} value\n * @param {number} [precision=0]        Optional number of decimals after the\n *                                      decimal point. Zero by default.\n */\nexports.toFixed = function (value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  var splitValue = exports.splitNumber(value)\n  var rounded = exports.roundDigits(splitValue, splitValue.exponent + 1 + (precision || 0));\n  var c = rounded.coefficients;\n  var p = rounded.exponent + 1; // exponent may have changed\n\n  // append zeros if needed\n  var pp = p + (precision || 0);\n  if (c.length < pp) {\n    c = c.concat(zeros(pp - c.length));\n  }\n\n  // prepend zeros if needed\n  if (p < 0) {\n    c = zeros(-p + 1).concat(c);\n    p = 1;\n  }\n\n  // insert a dot if needed\n  if (precision) {\n    c.splice(p, 0, (p === 0) ? '0.' : '.');\n  }\n\n  return rounded.sign + c.join('');\n};\n\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {number | string} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n */\nexports.toExponential = function (value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  // round if needed, else create a clone\n  var split = exports.splitNumber(value)\n  var rounded = precision ? exports.roundDigits(split, precision) : split;\n  var c = rounded.coefficients;\n  var e = rounded.exponent;\n\n  // append zeros if needed\n  if (c.length < precision) {\n    c = c.concat(zeros(precision - c.length));\n  }\n\n  // format as `C.CCCe+EEE` or `C.CCCe-EEE`\n  var first = c.shift();\n  return rounded.sign + first + (c.length > 0 ? ('.' + c.join('')) : '') +\n      'e' + (e >= 0 ? '+' : '') + e;\n}\n\n/**\n * Format a number with a certain precision\n * @param {number | string} value\n * @param {number} [precision=undefined] Optional number of digits.\n * @param {{lower: number | undefined, upper: number | undefined}} [options]\n *                                       By default:\n *                                         lower = 1e-3 (excl)\n *                                         upper = 1e+5 (incl)\n * @return {string}\n */\nexports.toPrecision = function (value, precision, options) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  // determine lower and upper bound for exponential notation.\n  var lower = (options && options.lower !== undefined) ? options.lower : 1e-3;\n  var upper = (options && options.upper !== undefined) ? options.upper : 1e+5;\n\n  var split = exports.splitNumber(value)\n  var abs = Math.abs(Math.pow(10, split.exponent));\n  if (abs < lower || abs >= upper) {\n    // exponential notation\n    return exports.toExponential(value, precision);\n  }\n  else {\n    var rounded = precision ? exports.roundDigits(split, precision) : split;\n    var c = rounded.coefficients;\n    var e = rounded.exponent;\n\n    // append trailing zeros\n    if (c.length < precision) {\n      c = c.concat(zeros(precision - c.length));\n    }\n\n    // append trailing zeros\n    // TODO: simplify the next statement\n    c = c.concat(zeros(e - c.length + 1 +\n        (c.length < precision ? precision - c.length : 0)));\n\n    // prepend zeros\n    c = zeros(-e).concat(c);\n\n    var dot = e > 0 ? e : 0;\n    if (dot < c.length - 1) {\n      c.splice(dot + 1, 0, '.');\n    }\n\n    return rounded.sign + c.join('');\n  }\n}\n\n/**\n * Round the number of digits of a number *\n * @param {SplitValue} split       A value split with .splitNumber(value)\n * @param {number} precision  A positive integer\n * @return {SplitValue}\n *              Returns an object containing sign, coefficients, and exponent\n *              with rounded digits\n */\nexports.roundDigits = function (split, precision) {\n  // create a clone\n  var rounded = {\n    sign: split.sign,\n    coefficients: split.coefficients,\n    exponent: split.exponent\n  }\n  var c = rounded.coefficients;\n\n  // prepend zeros if needed\n  while (precision <= 0) {\n    c.unshift(0);\n    rounded.exponent++;\n    precision++;\n  }\n\n  if (c.length > precision) {\n    var removed = c.splice(precision, c.length - precision);\n\n    if (removed[0] >= 5) {\n      var i = precision - 1;\n      c[i]++;\n      while (c[i] === 10) {\n        c.pop();\n        if (i === 0) {\n          c.unshift(0);\n          rounded.exponent++;\n          i++;\n        }\n        i--;\n        c[i]++;\n      }\n    }\n  }\n\n  return rounded;\n};\n\n/**\n * Create an array filled with zeros.\n * @param {number} length\n * @return {Array}\n */\nfunction zeros(length) {\n  var arr = [];\n  for (var i = 0; i < length; i++) {\n    arr.push(0);\n  }\n  return arr;\n}\n\n/**\n * Count the number of significant digits of a number.\n *\n * For example:\n *   2.34 returns 3\n *   0.0034 returns 2\n *   120.5e+30 returns 4\n *\n * @param {number} value\n * @return {number} digits   Number of significant digits\n */\nexports.digits = function(value) {\n  return value\n      .toExponential()\n      .replace(/e.*$/, '')          // remove exponential notation\n      .replace( /^0\\.?0*|\\./, '')   // remove decimal point and leading zeros\n      .length\n};\n\n/**\n * Minimum number added to one that makes the result different than one\n */\nexports.DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;\n\n/**\n * Compares two floating point numbers.\n * @param {number} x          First value to compare\n * @param {number} y          Second value to compare\n * @param {number} [epsilon]  The maximum relative difference between x and y\n *                            If epsilon is undefined or null, the function will\n *                            test whether x and y are exactly equal.\n * @return {boolean} whether the two numbers are nearly equal\n*/\nexports.nearlyEqual = function(x, y, epsilon) {\n  // if epsilon is null or undefined, test whether x and y are exactly equal\n  if (epsilon == null) {\n    return x == y;\n  }\n\n  // use \"==\" operator, handles infinities\n  if (x == y) {\n    return true;\n  }\n\n  // NaN\n  if (isNaN(x) || isNaN(y)) {\n    return false;\n  }\n\n  // at this point x and y should be finite\n  if(isFinite(x) && isFinite(y)) {\n    // check numbers are very close, needed when comparing numbers near zero\n    var diff = Math.abs(x - y);\n    if (diff < exports.DBL_EPSILON) {\n      return true;\n    }\n    else {\n      // use relative error\n      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;\n    }\n  }\n\n  // Infinite and Number or negative Infinite and positive Infinite cases\n  return false;\n};\n","'use strict';\n\nvar latex = require('../../utils/latex');\nvar stringify = require('../../utils/string').stringify;\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\nvar setSafeProperty = require('../../utils/customs').setSafeProperty;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n  var ArrayNode = load(require('./ArrayNode'));\n  var matrix = load(require('../../type/matrix/function/matrix'));\n  var assign = load(require('./utils/assign'));\n  var access = load(require('./utils/access'));\n\n  var keywords = require('../keywords');\n  var operators = require('../operators');\n\n  /**\n   * @constructor AssignmentNode\n   * @extends {Node}\n   *\n   * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or\n   * replace a subset of a matrix like `A[2,2]=42`.\n   *\n   * Syntax:\n   *\n   *     new AssignmentNode(symbol, value)\n   *     new AssignmentNode(object, index, value)\n   *\n   * Usage:\n   *\n   *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2));                      // a=2\n   *    new AssignmentNode(new SymbolNode('a'), new IndexNode('b'), new ConstantNode(2))   // a.b=2\n   *    new AssignmentNode(new SymbolNode('a'), new IndexNode(1, 2), new ConstantNode(3))  // a[1,2]=3\n   *\n   * @param {SymbolNode | AccessorNode} object  Object on which to assign a value\n   * @param {IndexNode} [index=null]            Index, property name or matrix\n   *                                            index. Optional. If not provided\n   *                                            and `object` is a SymbolNode,\n   *                                            the property is assigned to the\n   *                                            global scope.\n   * @param {Node} value                        The value to be assigned\n   */\n  function AssignmentNode(object, index, value) {\n    if (!(this instanceof AssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.object = object;\n    this.index = value ? index : null;\n    this.value = value ? value : index;\n\n    // validate input\n    if (!type.isSymbolNode(object) && !type.isAccessorNode(object)) {\n      throw new TypeError('SymbolNode or AccessorNode expected as \"object\"');\n    }\n    if (type.isSymbolNode(object) && object.name === 'end') {\n      throw new Error('Cannot assign to symbol \"end\"');\n    }\n    if (this.index && !type.isIndexNode(this.index)) { // index is optional\n      throw new TypeError('IndexNode expected as \"index\"');\n    }\n    if (!type.isNode(this.value)) {\n      throw new TypeError('Node expected as \"value\"');\n    }\n\n    // readonly property name\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return (this.index.isObjectProperty())\n              ? this.index.getObjectProperty()\n              : '';\n        }\n        else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function () {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AssignmentNode.prototype = new Node();\n\n  AssignmentNode.prototype.type = 'AssignmentNode';\n\n  AssignmentNode.prototype.isAssignmentNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {AssignmentNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @private\n   */\n  function compileAssignmentNode (node, defs, args) {\n    if (!(node instanceof AssignmentNode)) {\n      throw new TypeError('No valid AssignmentNode')\n    }\n\n    defs.assign = assign;\n    defs.access = access;\n    defs.getSafeProperty = getSafeProperty;\n    defs.setSafeProperty = setSafeProperty;\n\n    var size;\n    var object = compile(node.object, defs, args);\n    var index = node.index ? compile(node.index, defs, args) : null;\n    var value = compile(node.value, defs, args);\n    var jsName = stringify(node.object.name);\n\n    if (!node.index) {\n      // apply a variable to the scope, for example `a=2`\n      if (!type.isSymbolNode(node.object)) {\n        throw new TypeError('SymbolNode expected as object');\n      }\n\n      return 'setSafeProperty(scope, ' + jsName + ', ' + value + ')';\n    }\n    else if (node.index.isObjectProperty()) {\n      // apply an object property for example `a.b=2`\n      var jsProp = stringify(node.index.getObjectProperty());\n      return 'setSafeProperty(' + object + ', ' + jsProp + ', ' + value + ')';\n    }\n    else if (type.isSymbolNode(node.object)) {\n      // update a matrix subset, for example `a[2]=3`\n      size = node.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';\n\n      // apply updated object to scope\n      return '(function () {' +\n          '  var object = ' + object + ';' +\n          '  var value = ' + value + ';' +\n          '  ' + size +\n          '  setSafeProperty(scope, ' + jsName + ', assign(object, ' + index + ', value));' +\n          '  return value;' +\n          '})()';\n    }\n    else { // type.isAccessorNode(node.object) === true\n      // update a matrix subset, for example `a.b[2]=3`\n      size = node.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';\n\n      // we will not use the compile function of the AccessorNode, but compile it\n      // ourselves here as we need the parent object of the AccessorNode:\n      // wee need to apply the updated object to parent object\n      var parentObject = compile(node.object.object, defs, args);\n\n      if (node.object.index.isObjectProperty()) {\n        var jsParentProperty = stringify(node.object.index.getObjectProperty());\n        return '(function () {' +\n            '  var parent = ' + parentObject + ';' +\n            '  var object = getSafeProperty(parent, ' + jsParentProperty + ');' + // parentIndex is a property\n            '  var value = ' + value + ';' +\n            size +\n            '  setSafeProperty(parent, ' + jsParentProperty + ', assign(object, ' + index + ', value));' +\n            '  return value;' +\n            '})()';\n      }\n      else {\n        // if some parameters use the 'end' parameter, we need to calculate the size\n        var parentSize = node.object.index.needsSize() ? 'var size = math.size(parent).valueOf();' : '';\n        var parentIndex = compile(node.object.index, defs, args);\n\n        return '(function () {' +\n            '  var parent = ' + parentObject + ';' +\n            '  ' + parentSize +\n            '  var parentIndex = ' + parentIndex + ';' +\n            '  var object = access(parent, parentIndex);' +\n            '  var value = ' + value + ';' +\n            '  ' + size +\n            '  assign(parent, parentIndex, assign(object, ' + index + ', value));' +\n            '  return value;' +\n            '})()';\n      }\n    }\n  }\n\n  // register the compile function\n  register(AssignmentNode.prototype.type, compileAssignmentNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  AssignmentNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n    if (this.index) {\n      callback(this.index, 'index', this);\n    }\n    callback(this.value, 'value', this);\n  };\n\n  /**\n   * Create a new AssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {AssignmentNode} Returns a transformed copy of the node\n   */\n  AssignmentNode.prototype.map = function (callback) {\n    var object = this._ifNode(callback(this.object, 'object', this));\n    var index = this.index\n        ? this._ifNode(callback(this.index, 'index', this))\n        : null;\n    var value = this._ifNode(callback(this.value, 'value', this));\n\n    return new AssignmentNode(object, index, value);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {AssignmentNode}\n   */\n  AssignmentNode.prototype.clone = function() {\n    return new AssignmentNode(this.object, this.index, this.value);\n  };\n\n  /*\n   * Is parenthesis needed?\n   * @param {node} node\n   * @param {string} [parenthesis='keep']\n   * @private\n   */\n  function needParenthesis(node, parenthesis) {\n    if (!parenthesis) {\n      parenthesis = 'keep';\n    }\n\n    var precedence = operators.getPrecedence(node, parenthesis);\n    var exprPrecedence = operators.getPrecedence(node.value, parenthesis);\n    return (parenthesis === 'all')\n      || ((exprPrecedence !== null) && (exprPrecedence <= precedence));\n  }\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string}\n   */\n  AssignmentNode.prototype._toString = function(options) {\n    var object = this.object.toString(options);\n    var index = this.index ? this.index.toString(options) : '';\n    var value = this.value.toString(options);\n    if (needParenthesis(this, options && options.parenthesis)) {\n      value = '(' + value + ')';\n    }\n\n    return object + index + ' = ' + value;\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string}\n   */\n  AssignmentNode.prototype.toHTML = function(options) {\n    var object = this.object.toHTML(options);\n    var index = this.index ? this.index.toHTML(options) : '';\n    var value = this.value.toHTML(options);\n    if (needParenthesis(this, options && options.parenthesis)) {\n      value = '<span class=\"math-paranthesis math-round-parenthesis\">(</span>' + value + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + index + '<span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + value;\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string}\n   */\n  AssignmentNode.prototype._toTex = function(options) {\n    var object = this.object.toTex(options);\n    var index = this.index ? this.index.toTex(options) : '';\n    var value = this.value.toTex(options);\n    if (needParenthesis(this, options && options.parenthesis)) {\n      value = '\\\\left(' + value + '\\\\right)';\n    }\n\n    return object + index + ':=' + value;\n  };\n\n  return AssignmentNode;\n}\n\nexports.name = 'AssignmentNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\n/**\n * Determine the type of a variable\n *\n *     type(x)\n *\n * The following types are recognized:\n *\n *     'undefined'\n *     'null'\n *     'boolean'\n *     'number'\n *     'string'\n *     'Array'\n *     'Function'\n *     'Date'\n *     'RegExp'\n *     'Object'\n *\n * @param {*} x\n * @return {string} Returns the name of the type. Primitive types are lower case,\n *                  non-primitive types are upper-camel-case.\n *                  For example 'number', 'string', 'Array', 'Date'.\n */\nexports.type = function(x) {\n  var type = typeof x;\n\n  if (type === 'object') {\n    if (x === null)           return 'null';\n    if (Array.isArray(x))     return 'Array';\n    if (x instanceof Date)    return 'Date';\n    if (x instanceof RegExp)  return 'RegExp';\n    if (x instanceof Boolean) return 'boolean';\n    if (x instanceof Number)  return 'number';\n    if (x instanceof String)  return 'string';\n\n    return 'Object';\n  }\n\n  if (type === 'function')    return 'Function';\n\n  return type;\n};\n","'use strict';\n\nvar formatNumber = require('./number').format;\nvar formatBigNumber = require('./bignumber/formatter').format;\nvar isBigNumber = require('./bignumber/isBigNumber');\n\n/**\n * Test whether value is a string\n * @param {*} value\n * @return {boolean} isString\n */\nexports.isString = function(value) {\n  return typeof value === 'string';\n};\n\n/**\n * Check if a text ends with a certain string.\n * @param {string} text\n * @param {string} search\n */\nexports.endsWith = function(text, search) {\n  var start = text.length - search.length;\n  var end = text.length;\n  return (text.substring(start, end) === search);\n};\n\n/**\n * Format a value of any type into a string.\n *\n * Usage:\n *     math.format(value)\n *     math.format(value, precision)\n *\n * When value is a function:\n *\n * - When the function has a property `syntax`, it returns this\n *   syntax description.\n * - In other cases, a string `'function'` is returned.\n *\n * When `value` is an Object:\n *\n * - When the object contains a property `format` being a function, this\n *   function is invoked as `value.format(options)` and the result is returned.\n * - When the object has its own `toString` method, this method is invoked\n *   and the result is returned.\n * - In other cases the function will loop over all object properties and\n *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n *\n * Example usage:\n *     math.format(2/7);                // '0.2857142857142857'\n *     math.format(math.pi, 3);         // '3.14'\n *     math.format(new Complex(2, 3));  // '2 + 3i'\n *     math.format('hello');            // '\"hello\"'\n *\n * @param {*} value             Value to be stringified\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @return {string} str\n */\nexports.format = function(value, options) {\n  if (typeof value === 'number') {\n    return formatNumber(value, options);\n  }\n\n  if (isBigNumber(value)) {\n    return formatBigNumber(value, options);\n  }\n\n  // note: we use unsafe duck-typing here to check for Fractions, this is\n  // ok here since we're only invoking toString or concatenating its values\n  if (looksLikeFraction(value)) {\n    if (!options || options.fraction !== 'decimal') {\n      // output as ratio, like '1/3'\n      return (value.s * value.n) + '/' + value.d;\n    }\n    else {\n      // output as decimal, like '0.(3)'\n      return value.toString();\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return formatArray(value, options);\n  }\n\n  if (exports.isString(value)) {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'function') {\n    return value.syntax ? String(value.syntax) : 'function';\n  }\n\n  if (value && typeof value === 'object') {\n    if (typeof value.format === 'function') {\n      return value.format(options);\n    }\n    else if (value && value.toString() !== {}.toString()) {\n      // this object has a non-native toString method, use that one\n      return value.toString();\n    }\n    else {\n      var entries = [];\n\n      for (var key in value) {\n        if (value.hasOwnProperty(key)) {\n          entries.push('\"' + key + '\": ' + exports.format(value[key], options));\n        }\n      }\n\n      return '{' + entries.join(', ') + '}';\n    }\n  }\n\n  return String(value);\n};\n\n/**\n * Stringify a value into a string enclosed in double quotes.\n * Unescaped double quotes and backslashes inside the value are escaped.\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var text = String(value);\n  var escaped = '';\n  var i = 0;\n  while (i < text.length) {\n    var c = text.charAt(i);\n\n    if (c === '\\\\') {\n      escaped += c;\n      i++;\n\n      c = text.charAt(i);\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n        escaped += '\\\\';  // no valid escape character -> escape it\n      }\n      escaped += c;\n    }\n    else if (c === '\"') {\n      escaped += '\\\\\"';\n    }\n    else {\n      escaped += c;\n    }\n    i++;\n  }\n\n  return '\"' + escaped + '\"';\n}\n\n/**\n * Escape special HTML characters\n * @param {*} value\n * @return {string}\n */\nexports.escape = function (value) {\n  var text = String(value);\n  text = text.replace(/&/g, '&amp;')\n\t\t\t .replace(/\"/g, '&quot;')\n\t\t\t .replace(/'/g, '&#39;')\n\t\t\t .replace(/</g, '&lt;')\n\t\t\t .replace(/>/g, '&gt;');\n  \n  return text;\n}\n\n/**\n * Recursively format an n-dimensional matrix\n * Example output: \"[[1, 2], [3, 4]]\"\n * @param {Array} array\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @returns {string} str\n */\nfunction formatArray (array, options) {\n  if (Array.isArray(array)) {\n    var str = '[';\n    var len = array.length;\n    for (var i = 0; i < len; i++) {\n      if (i != 0) {\n        str += ', ';\n      }\n      str += formatArray(array[i], options);\n    }\n    str += ']';\n    return str;\n  }\n  else {\n    return exports.format(array, options);\n  }\n}\n\n/**\n * Check whether a value looks like a Fraction (unsafe duck-type check)\n * @param {*} value\n * @return {boolean}\n */\nfunction looksLikeFraction (value) {\n  return (value &&\n      typeof value === 'object' &&\n      typeof value.s === 'number' &&\n      typeof value.n === 'number' &&\n      typeof value.d === 'number') || false;\n}\n","'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var FunctionNode = math.expression.node.FunctionNode;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var SymbolNode = math.expression.node.SymbolNode;\n\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    'add': true,\n    'multiply': true\n  }\n  var associative = {\n    'add': true,\n    'multiply': true\n  }\n\n\n  function isCommutative(node, context) {\n    if (!type.isOperatorNode(node)) {\n      return true;\n    }\n    var name = node.fn.toString();\n    if (context && context.hasOwnProperty(name) && context[name].hasOwnProperty('commutative')) {\n      return context[name].commutative;\n    }\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!type.isOperatorNode(node)) {\n      return false;\n    }\n    var name = node.fn.toString();\n    if (context && context.hasOwnProperty(name) && context[name].hasOwnProperty('associative')) {\n      return context[name].associative;\n    }\n    return associative[name] || false;\n  }\n\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node);\n    for (var i=0; i<node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n  function allChildren(node) {\n    var op;\n    var children = [];\n    var findChildren = function(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if (type.isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        }\n        else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    }\n    else {\n      return node.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i])\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i])\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (type.isOperatorNode(node)) {\n      return function(args){\n        try{\n          return new OperatorNode(node.op, node.fn, args);\n        } catch(err){\n          console.error(err);\n          return [];\n        }\n      };\n    }\n    else {\n      return function(args){\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n}\n\nexports.factory = factory;\nexports.math = true;","'use strict';\n\nvar hasOwnProperty = require('./object').hasOwnProperty;\n\n/**\n * Get a property of a plain object\n * Throws an error in case the object is not a plain object or the\n * property is not defined on the object itself\n * @param {Object} object\n * @param {string} prop\n * @return {*} Returns the property value when safe\n */\nfunction getSafeProperty (object, prop) {\n  // only allow getting safe properties of a plain object\n  if (isPlainObject(object) && isSafeProperty(object, prop)) {\n    return object[prop];\n  }\n\n  if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {\n    throw new Error('Cannot access method \"' + prop + '\" as a property');\n  }\n\n  throw new Error('No access to property \"' + prop + '\"');\n}\n\n/**\n * Set a property on a plain object.\n * Throws an error in case the object is not a plain object or the\n * property would override an inherited property like .constructor or .toString\n * @param {Object} object\n * @param {string} prop\n * @param {*} value\n * @return {*} Returns the value\n */\n// TODO: merge this function into access.js?\nfunction setSafeProperty (object, prop, value) {\n  // only allow setting safe properties of a plain object\n  if (isPlainObject(object) && isSafeProperty(object, prop)) {\n    return object[prop] = value;\n  }\n\n  throw new Error('No access to property \"' + prop + '\"');\n}\n\n/**\n * Test whether a property is safe to use for an object.\n * For example .toString and .constructor are not safe\n * @param {string} prop\n * @return {boolean} Returns true when safe\n */\nfunction isSafeProperty (object, prop) {\n  if (!object || typeof object !== 'object') {\n    return false;\n  }\n  // SAFE: whitelisted\n  // e.g length\n  if (hasOwnProperty(safeNativeProperties, prop)) {\n    return true;\n  }\n  // UNSAFE: inherited from Object prototype\n  // e.g constructor\n  if (prop in Object.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Object.prototype is a root object\n    return false;\n  }\n  // UNSAFE: inherited from Function prototype\n  // e.g call, apply\n  if (prop in Function.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Function.prototype is a root object\n    return false;\n  }\n  return true;\n}\n\n/**\n * Validate whether a method is safe.\n * Throws an error when that's not the case.\n * @param {Object} object\n * @param {string} method\n */\n// TODO: merge this function into assign.js?\nfunction validateSafeMethod (object, method) {\n  if (!isSafeMethod(object, method)) {\n    throw new Error('No access to method \"' + method + '\"');\n  }\n}\n\n/**\n * Check whether a method is safe.\n * Throws an error when that's not the case (for example for `constructor`).\n * @param {Object} object\n * @param {string} method\n * @return {boolean} Returns true when safe, false otherwise\n */\nfunction isSafeMethod (object, method) {\n  if (!object || typeof object[method] !== 'function') {\n    return false;\n  }\n  // UNSAFE: ghosted\n  // e.g overridden toString\n  // Note that IE10 doesn't support __proto__ and we can't do this check there.\n  if (hasOwnProperty(object, method) &&\n      (object.__proto__ && (method in object.__proto__))) {\n    return false;\n  }\n  // SAFE: whitelisted\n  // e.g toString\n  if (hasOwnProperty(safeNativeMethods, method)) {\n    return true;\n  }\n  // UNSAFE: inherited from Object prototype\n  // e.g constructor\n  if (method in Object.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Object.prototype is a root object\n    return false;\n  }\n  // UNSAFE: inherited from Function prototype\n  // e.g call, apply\n  if (method in Function.prototype) {\n    // 'in' is used instead of hasOwnProperty for nodejs v0.10\n    // which is inconsistent on root prototypes. It is safe\n    // here because Function.prototype is a root object\n    return false;\n  }\n  return true;\n}\n\nfunction isPlainObject (object) {\n  return typeof object === 'object' && object && object.constructor === Object;\n}\n\nvar safeNativeProperties = {\n  length: true,\n  name: true\n};\n\nvar safeNativeMethods = {\n  toString: true,\n  valueOf: true,\n  toLocaleString: true\n};\n\nexports.getSafeProperty = getSafeProperty;\nexports.setSafeProperty = setSafeProperty;\nexports.isSafeProperty = isSafeProperty;\nexports.validateSafeMethod = validateSafeMethod;\nexports.isSafeMethod = isSafeMethod;\nexports.isPlainObject = isPlainObject;\n","'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var ConstantNode = math.expression.node.ConstantNode;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var FunctionNode = math.expression.node.FunctionNode;\n  var ParenthesisNode = math.expression.node.ParenthesisNode;\n\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     var f = math.parse('2 * 1 * x ^ (2 - 1)');\n   *     math.simplify.simpifyCore(f);                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]); // Node {2 * x};\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n  function simplifyCore(node) {\n    if (type.isOperatorNode(node) && node.args.length <= 2) {\n      var a0 = simplifyCore(node.args[0]);\n      var a1 = node.args[1] && simplifyCore(node.args[1]);\n      if (node.op === \"+\") {\n          if (node.args.length === 1) {\n            return node.args[0];\n          }\n          if (type.isConstantNode(a0)) {\n              if (a0.value === \"0\") {\n                  return a1;\n              } else if (type.isConstantNode(a1) && a0.value && a0.value.length < 5 && a1.value && a1.value.length < 5) {\n                  return new ConstantNode(Number(a0.value) + Number(a1.value));\n              }\n          }\n          if (type.isConstantNode(a1) && a1.value === \"0\") {\n              return a0;\n          }\n          if (node.args.length === 2 && type.isOperatorNode(a1) && a1.op === '-' && a1.fn === 'unaryMinus') {\n              return new OperatorNode('-', 'subtract', [a0,a1.args[0]]);\n          }\n          return new OperatorNode(node.op, node.fn, a1 ? [a0,a1] : [a0]);\n      } else if (node.op === \"-\") {\n          if (type.isConstantNode(a0) && a1) {\n              if (type.isConstantNode(a1) && a0.value && a0.value.length < 5 && a1.value && a1.value.length < 5) {\n                  return new ConstantNode(Number(a0.value) - Number(a1.value));\n              } else if (a0.value === \"0\") {\n                  return new OperatorNode(\"-\", \"unaryMinus\", [a1]);\n              }\n          }\n          if (node.fn === \"subtract\" && node.args.length === 2) {\n              if (type.isConstantNode(a1) && a1.value === \"0\") {\n                  return a0;\n              }\n              if (type.isOperatorNode(a1) && a1.fn === \"unaryMinus\") {\n                  return simplifyCore(new OperatorNode(\"+\", \"add\", [a0, a1.args[0]]));\n              }\n              return new OperatorNode(node.op, node.fn, [a0,a1]);\n          } else if (node.fn === \"unaryMinus\") {\n              if (type.isOperatorNode(a0)) {\n                  if (a0.fn === 'unaryMinus') {\n                      return a0.args[0];\n                  } else if (a0.fn === 'subtract') {\n                      return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n                  }\n              }\n              return new OperatorNode(node.op, node.fn, [a0]);\n          }\n          throw new Error('never happens');\n      } else if (node.op === \"*\") {\n          if (type.isConstantNode(a0)) {\n              if (a0.value === \"0\") {\n                  return node0;\n              } else if (a0.value === \"1\") {\n                  return a1;\n              } else if (type.isConstantNode(a1) && a0.value && a0.value.length < 5 && a1.value && a1.value.length < 5) {\n                  return new ConstantNode(Number(a0.value) * Number(a1.value));\n              }\n          }\n          if (type.isConstantNode(a1)) {\n              if (a1.value === \"0\") {\n                  return node0;\n              } else if (a1.value === \"1\") {\n                  return a0;\n              } else if (type.isOperatorNode(a0) && a0.op === node.op) {\n                  var a00 = a0.args[0];\n                  if (type.isConstantNode(a00) && a1.value && a1.value.length < 5 && a00.value && a00.value.length < 5) {\n                      var a00_a1 =  new ConstantNode(Number(a0.args[0].value) * Number(a1.value));\n                      return new OperatorNode(node.op, node.fn, [a00_a1, a0.args[1]]); // constants on left\n                  }\n              }\n              return new OperatorNode(node.op, node.fn, [a1, a0]); // constants on left\n          }\n          return new OperatorNode(node.op, node.fn, [a0, a1]);\n      } else if (node.op === \"/\") {\n          if (type.isConstantNode(a0)) {\n              if (a0.value === \"0\") {\n                  return node0;\n              } else if (type.isConstantNode(a1) && a0.value && a0.value.length < 5 && (a1.value === \"1\" || a1.value===\"2\" || a1.value===\"4\")) {\n                  return new ConstantNode(Number(a0.value) / Number(a1.value));\n              }\n          }\n          return new OperatorNode(node.op, node.fn, [a0, a1]);\n      } else if (node.op === \"^\") {\n          if (type.isConstantNode(a1)) {\n              if (a1.value === \"0\") {\n                  return node1;\n              } else if (a1.value === \"1\") {\n                  return a0;\n              } else {\n                  if (type.isConstantNode(a0) && \n                      a0.value && a0.value.length < 5 && \n                      a1.value && a1.value.length < 2) { \n                      // fold constant\n                      return new ConstantNode(\n                          math.pow(Number(a0.value), Number(a1.value)));\n                  } else if (type.isOperatorNode(a0) && a0.op === \"^\") {\n                      var a01 = a0.args[1];\n                      if (type.isConstantNode(a01)) {\n                          return new OperatorNode(node.op, node.fn, [\n                              a0.args[0], \n                              new ConstantNode(a01.value * a1.value)\n                          ]);\n                      }\n                  }\n              }\n          }\n          return new OperatorNode(node.op, node.fn, [a0, a1]);\n      }\n    } else if (type.isParenthesisNode(node)) {\n        var c = simplifyCore(node.content);\n        if (type.isParenthesisNode(c) || type.isSymbolNode(c) || type.isConstantNode(c)) {\n            return c;\n        }\n        return new ParenthesisNode(c);\n    } else if (type.isFunctionNode(node)) {\n          var args = node.args.map(simplifyCore);\n          if (args.length === 1) {\n              if (type.isParenthesisNode(args[0])) {\n                  args[0] = args[0].content;\n              }\n          }\n          return new FunctionNode(simplifyCore(node.fn), args);\n    } else {\n        // cannot simplify\n    }\n    return node;\n  }\n\n  return simplifyCore;\n}\n\nexports.math = true;\nexports.name = 'simplifyCore';\nexports.path = 'algebra.simplify';\nexports.factory = factory;\n","/**\n * Get a unique name for an argument name to store in defs\n * @param {Object} defs\n * @return {string} A string like 'arg1', 'arg2', ...\n * @private\n */\nfunction getUniqueArgumentName (defs) {\n  return 'arg' + Object.keys(defs).length\n}\n\nmodule.exports = getUniqueArgumentName;\n","'use strict';\n\nvar latex = require('../../utils/latex');\nvar stringify = require('../../utils/string').stringify;\nvar escape = require('../../utils/string').escape;\nvar extend = require('../../utils/object').extend;\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\nvar map = require('../../utils/array').map;\nvar join = require('../../utils/array').join;\nvar validateSafeMethod = require('../../utils/customs').validateSafeMethod;\nvar getUniqueArgumentName = require('./utils/getUniqueArgumentName');\n\nfunction factory (type, config, load, typed, math) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n  var SymbolNode = load(require('./SymbolNode'));\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    }\n\n    // validate input\n    if (!type.isNode(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n    if (!Array.isArray(args) || !args.every(type.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || [];\n\n    // readonly property name\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function () {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n\n    // TODO: deprecated since v3, remove some day\n    var deprecated = function () {\n      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');\n    };\n    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });\n  }\n\n  FunctionNode.prototype = new Node();\n\n  FunctionNode.prototype.type = 'FunctionNode';\n\n  FunctionNode.prototype.isFunctionNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {FunctionNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileFunctionNode(node, defs, args) {\n    if (!(node instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode')\n    }\n\n    // compile fn and arguments\n    var jsFn = compile(node.fn, defs, args);\n    var jsArgs = map(node.args, function (arg) {\n      return compile(arg, defs, args);\n    });\n    var jsScope = compileScope(defs, args);\n    var argsName;\n\n    if (type.isSymbolNode(node.fn)) {\n      // we can statically determine whether the function has an rawArgs property\n      var name = node.fn.name;\n      var fn = hasOwnProperty(defs.math, name) ? defs.math[name] : undefined;\n      var isRaw = (typeof fn === 'function') && (fn.rawArgs == true);\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        argsName = getUniqueArgumentName(defs);\n        defs[argsName] = node.args;\n\n        return jsFn + '(' + argsName + ', math, ' + jsScope + ')'; // \"raw\" evaluation\n      }\n      else {\n        return jsFn + '(' + join(jsArgs, ', ') + ')';              // \"regular\" evaluation\n      }\n    }\n    else if (type.isAccessorNode(node.fn) &&\n        type.isIndexNode(node.fn.index) && node.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      argsName = getUniqueArgumentName(defs);\n      defs[argsName] = node.args;\n      defs.validateSafeMethod = validateSafeMethod\n\n      var jsObject = compile(node.fn.object, defs, args);\n      var jsProp = stringify(node.fn.index.getObjectProperty());\n\n      return '(function () {' +\n          'var object = ' + jsObject + ';' +\n          'validateSafeMethod(object, ' + jsProp + ');' +\n          'return (object[' + jsProp + '] && object[' + jsProp + '].rawArgs) ' +\n          ' ? object[' + jsProp + '](' + argsName + ', math, ' + jsScope + ')' + // \"raw\" evaluation\n          ' : object[' + jsProp + '](' + join(jsArgs, ', ') + ')' +              // \"regular\" evaluation\n          '})()';\n    }\n    else { // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      argsName = getUniqueArgumentName(defs);\n      defs[argsName] = node.args;\n\n      return '(function () {' +\n          'var fn = ' + jsFn + ';' +\n          'return (fn && fn.rawArgs) ' +\n          ' ? fn(' + argsName + ', math, ' + jsScope + ')' +  // \"raw\" evaluation\n          ' : fn(' + join(jsArgs, ', ') + ')' +               // \"regular\" evaluation\n          '})()';\n    }\n  }\n\n  // register the compile function\n  register(FunctionNode.prototype.type, compileFunctionNode);\n\n  /**\n   * Merge function arguments into scope before passing to the actual function.\n   * This is needed when the function has `rawArgs=true`. In that case we have\n   * to pass the `scope` as third argument, including any variables of\n   * enclosing functions.\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileScope (defs, args) {\n    var names = Object.keys(args)\n        // .map(function (arg) {\n        //   return args[arg];\n        // });\n    if (names.length === 0) {\n      return 'scope';\n    }\n    else {\n      // merge arguments into scope\n      defs.extend = extend;\n\n      var jsArgs = map(names, function (name) {\n        return stringify(name) + ': ' + args[name];\n      });\n\n      return 'extend(extend({}, scope), {' + join(jsArgs, ', ') + '})';\n    }\n  }\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  FunctionNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this.fn.map(callback);\n    var args = [];\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n    return new FunctionNode(fn, args);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n\n  //backup Node's toString function\n  //@private\n  var nodeToString = FunctionNode.prototype.toString;\n\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n    if (options && (typeof options.handler === 'object') && hasOwnProperty(options.handler, name)) {\n      //callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    //fall back to Node's toString\n    return nodeToString.call(this, options);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n\n    var fn = type.isFunctionAssignmentNode(this.fn)\n        ? ('(' + this.fn.toString(options) + ')')\n        : this.fn.toString(options)\n\n    // format the arguments like \"add(2, 4.2)\"\n    return fn + '(' + args.join(', ') + ')';\n  };\n  \n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    });\n\n    // format the arguments like \"add(2, 4.2)\"\n    return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n  function expandTemplate(template, node, options) {\n    var latex = '';\n\n    // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n    var regex = new RegExp('\\\\$(?:\\\\{([a-z_][a-z_0-9]*)(?:\\\\[([0-9]+)\\\\])?\\\\}|\\\\$)', 'ig');\n\n    var inputPos = 0;   //position in the input string\n    var match;\n    while ((match = regex.exec(template)) !== null) {   //go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') { // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      }\n      else { // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n        if (match[2] === undefined) { //no square brackets\n          switch (typeof property) {\n            case 'string':\n              latex += property;\n              break;\n            case 'object':\n              if (type.isNode(property)) {\n                latex += property.toTex(options);\n              }\n              else if (Array.isArray(property)) {\n                //make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if (type.isNode(arg)) {\n                    return arg.toTex(options);\n                  }\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              }\n              else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n              break;\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        }\n        else { //with square brackets\n          if (type.isNode(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          }\n          else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n    latex += template.slice(inputPos);  //append rest of the template\n\n    return latex;\n  }\n\n  //backup Node's toTex function\n  //@private\n  var nodeToTex = FunctionNode.prototype.toTex;\n\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n    if (options && (typeof options.handler === 'object') && hasOwnProperty(options.handler, this.name)) {\n      //callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    }\n\n    //fall back to Node's toTex\n    return nodeToTex.call(this, options);\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) { //get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n\n    var latexConverter;\n\n    if (math[this.name] && ((typeof math[this.name].toTex === 'function') || (typeof math[this.name].toTex === 'object') || (typeof math[this.name].toTex === 'string'))) {\n      //.toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n    switch (typeof latexConverter) {\n      case 'function': //a callback function\n        customToTex = latexConverter(this, options);\n        break;\n      case 'string': //a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n      case 'object': //an object with different \"converters\" for different numbers of arguments\n        switch (typeof latexConverter[args.length]) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(latex.defaultTemplate, this, options);\n  };\n\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}\n\nexports.name = 'FunctionNode';\nexports.path = 'expression.node';\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\nexports.factory = factory;\n","'use strict';\n\nvar stringify = require('../../utils/string').stringify;\nvar escape = require('../../utils/string').escape;\nvar isSafeProperty = require('../../utils/customs').isSafeProperty;\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * @constructor ObjectNode\n   * @extends {Node}\n   * Holds an object with keys/values\n   * @param {Object.<string, Node>} [properties]   array with key/value pairs\n   */\n  function ObjectNode(properties) {\n    if (!(this instanceof ObjectNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.properties = properties || {};\n\n    // validate input\n    if (properties) {\n      if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\n            return type.isNode(properties[key]);\n          })) {\n        throw new TypeError('Object containing Nodes expected');\n      }\n    }\n  }\n\n  ObjectNode.prototype = new Node();\n\n  ObjectNode.prototype.type = 'ObjectNode';\n\n  ObjectNode.prototype.isObjectNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {ObjectNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} code\n   * @private\n   */\n  function compileObjectNode(node, defs, args) {\n    if (!(node instanceof ObjectNode)) {\n      throw new TypeError('No valid ObjectNode')\n    }\n\n    var entries = [];\n    for (var key in node.properties) {\n      if (hasOwnProperty(node.properties, key)) {\n        // we stringify/parse the key here to resolve unicode characters,\n        // so you cannot create a key like {\"co\\\\u006Estructor\": null} \n        var stringifiedKey = stringify(key)\n        var parsedKey = JSON.parse(stringifiedKey)\n        if (!isSafeProperty(node.properties, parsedKey)) {\n          throw new Error('No access to property \"' + parsedKey + '\"');\n        }\n\n        entries.push(stringifiedKey + ': ' + compile(node.properties[key], defs, args));\n      }\n    }\n    return '{' + entries.join(', ') + '}';\n  }\n\n  // register the compile function\n  register(ObjectNode.prototype.type, compileObjectNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  ObjectNode.prototype.forEach = function (callback) {\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n      }\n    }\n  };\n\n  /**\n   * Create a new ObjectNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ObjectNode} Returns a transformed copy of the node\n   */\n  ObjectNode.prototype.map = function (callback) {\n    var properties = {};\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        properties[key] = this._ifNode(callback(this.properties[key],\n            'properties[' + stringify(key) + ']', this));\n      }\n    }\n    return new ObjectNode(properties);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ObjectNode}\n   */\n  ObjectNode.prototype.clone = function() {\n    var properties = {};\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        properties[key] = this.properties[key];\n      }\n    }\n    return new ObjectNode(properties);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ObjectNode.prototype._toString = function(options) {\n    var entries = [];\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n      }\n    }\n    return '{' + entries.join(', ') + '}';\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ObjectNode.prototype.toHTML = function(options) {\n    var entries = [];\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator math-property-assignment-operator math-binary-operator\">:</span>' + this.properties[key].toHTML(options));\n      }\n    }\n    return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ObjectNode.prototype._toTex = function(options) {\n    var entries = [];\n    for (var key in this.properties) {\n      if (this.properties.hasOwnProperty(key)) {\n        entries.push(\"\\\\mathbf{\" + key + ':} & ' + this.properties[key].toTex(options) + \"\\\\\\\\\");\n      }\n    }\n    return '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\n  };\n\n  return ObjectNode;\n}\n\nexports.name = 'ObjectNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\nvar map = require('../../utils/array').map;\nvar join = require('../../utils/array').join;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n  var ResultSet = load(require('../../type/resultset/ResultSet'));\n\n  /**\n   * @constructor BlockNode\n   * @extends {Node}\n   * Holds a set with blocks\n   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\n   *            An array with blocks, where a block is constructed as an Object\n   *            with properties block, which is a Node, and visible, which is\n   *            a boolean. The property visible is optional and is true by default\n   */\n  function BlockNode(blocks) {\n    if (!(this instanceof BlockNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    // validate input, copy blocks\n    if (!Array.isArray(blocks)) throw new Error('Array expected');\n    this.blocks = blocks.map(function (block) {\n      var node = block && block.node;\n      var visible = block && block.visible !== undefined ? block.visible : true;\n\n      if (!type.isNode(node)) throw new TypeError('Property \"node\" must be a Node');\n      if (typeof visible !== 'boolean') throw new TypeError('Property \"visible\" must be a boolean');\n\n      return {\n        node: node,\n        visible: visible\n      }\n    });\n  }\n\n  BlockNode.prototype = new Node();\n\n  BlockNode.prototype.type = 'BlockNode';\n\n  BlockNode.prototype.isBlockNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {BlockNode} node  The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileBlockNode (node, defs, args) {\n    if (!(node instanceof BlockNode)) {\n      throw new TypeError('No valid BlockNode')\n    }\n\n    defs.ResultSet = ResultSet;\n    var blocks = map(node.blocks, function (param) {\n      var js = compile(param.node, defs, args);\n      if (param.visible) {\n        return 'results.push(' + js + ');';\n      }\n      else {\n        return js + ';';\n      }\n    });\n\n    return '(function () {' +\n        'var results = [];' +\n        join(blocks, '') +\n        'return new ResultSet(results);' +\n        '})()';\n  }\n\n  // register the compile function\n  register(BlockNode.prototype.type, compileBlockNode);\n\n  /**\n   * Execute a callback for each of the child blocks of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  BlockNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.blocks.length; i++) {\n      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n    }\n  };\n\n  /**\n   * Create a new BlockNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {BlockNode} Returns a transformed copy of the node\n   */\n  BlockNode.prototype.map = function (callback) {\n    var blocks = [];\n    for (var i = 0; i < this.blocks.length; i++) {\n      var block = this.blocks[i];\n      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n      blocks[i] = {\n        node: node,\n        visible: block.visible\n      };\n    }\n    return new BlockNode(blocks);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {BlockNode}\n   */\n  BlockNode.prototype.clone = function () {\n    var blocks = this.blocks.map(function (block) {\n      return {\n        node: block.node,\n        visible: block.visible\n      };\n    });\n\n    return new BlockNode(blocks);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  BlockNode.prototype._toString = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toString(options) + (param.visible ? '' : ';');\n    }).join('\\n');\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  BlockNode.prototype.toHTML = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n    }).join('<span class=\"math-separator\"><br /></span>');\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  BlockNode.prototype._toTex = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toTex(options) + (param.visible ? '' : ';');\n    }).join('\\\\;\\\\;\\n');\n  };\n\n  return BlockNode;\n}\n\nexports.name = 'BlockNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\nvar stringify = require('../../utils/string').stringify;\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n  var IndexNode = load(require('./IndexNode'));\n  var access = load(require('./utils/access'));\n\n  /**\n   * @constructor AccessorNode\n   * @extends {Node}\n   * Access an object property or get a matrix subset\n   *\n   * @param {Node} object                 The object from which to retrieve\n   *                                      a property or subset.\n   * @param {IndexNode} index             IndexNode containing ranges\n   */\n  function AccessorNode(object, index) {\n    if (!(this instanceof AccessorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!type.isNode(object)) {\n      throw new TypeError('Node expected for parameter \"object\"');\n    }\n    if (!type.isIndexNode(index)) {\n      throw new TypeError('IndexNode expected for parameter \"index\"');\n    }\n\n    this.object = object || null;\n    this.index = index;\n\n    // readonly property name\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return (this.index.isObjectProperty())\n              ? this.index.getObjectProperty()\n              : '';\n        }\n        else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function () {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AccessorNode.prototype = new Node();\n\n  AccessorNode.prototype.type = 'AccessorNode';\n\n  AccessorNode.prototype.isAccessorNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {AccessorNode} node  Node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileAccessorNode(node, defs, args) {\n    if (!(node instanceof AccessorNode)) {\n      throw new TypeError('No valid AccessorNode')\n    }\n\n    defs.access = access;\n    defs.getSafeProperty = getSafeProperty;\n\n    var object = compile(node.object, defs, args);\n    var index = compile(node.index, defs, args);\n\n    if (node.index.isObjectProperty()) {\n      var jsProp = stringify(node.index.getObjectProperty());\n      return 'getSafeProperty(' + object + ', ' + jsProp + ')';\n    }\n    else if (node.index.needsSize()) {\n      // if some parameters use the 'end' parameter, we need to calculate the size\n      return '(function () {' +\n          '  var object = ' + object + ';' +\n          '  var size = math.size(object).valueOf();' +\n          '  return access(object, ' + index + ');' +\n          '})()';\n    }\n    else {\n      return 'access(' + object + ', ' + index + ')';\n    }\n  }\n\n  // register the compile function\n  register(AccessorNode.prototype.type, compileAccessorNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  AccessorNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n    callback(this.index, 'index', this);\n  };\n\n  /**\n   * Create a new AccessorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {AccessorNode} Returns a transformed copy of the node\n   */\n  AccessorNode.prototype.map = function (callback) {\n    return new AccessorNode(\n        this._ifNode(callback(this.object, 'object', this)),\n        this._ifNode(callback(this.index, 'index', this))\n    );\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {AccessorNode}\n   */\n  AccessorNode.prototype.clone = function () {\n    return new AccessorNode(this.object, this.index);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string}\n   */\n  AccessorNode.prototype._toString = function (options) {\n    var object = this.object.toString(options);\n    if (needParenthesis(this.object)) {\n      object = '(' + object + ')';\n    }\n\n    return object + this.index.toString(options);\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string}\n   */\n  AccessorNode.prototype.toHTML = function (options) {\n    var object = this.object.toHTML(options);\n    if (needParenthesis(this.object)) {\n      object = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + object + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + this.index.toHTML(options);\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string}\n   */\n  AccessorNode.prototype._toTex = function (options) {\n    var object = this.object.toTex(options);\n    if (needParenthesis(this.object)) {\n      object = '\\\\left(' + object + '\\\\right)';\n    }\n\n    return object + this.index.toTex(options);\n  };\n\n  /**\n   * Are parenthesis needed?\n   * @private\n   */\n  function needParenthesis(node) {\n    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?\n    return !(\n        type.isAccessorNode(node) ||\n        type.isArrayNode(node) ||\n        type.isConstantNode(node) ||\n        type.isFunctionNode(node) ||\n        type.isObjectNode(node) ||\n        type.isParenthesisNode(node) ||\n        type.isSymbolNode(node));\n  }\n\n  return AccessorNode;\n}\n\nexports.name = 'AccessorNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\n/**\n * Create a range error with the message:\n *     'Dimension mismatch (<actual size> != <expected size>)'\n * @param {number | number[]} actual        The actual size\n * @param {number | number[]} expected      The expected size\n * @param {string} [relation='!=']          Optional relation between actual\n *                                          and expected size: '!=', '<', etc.\n * @extends RangeError\n */\nfunction DimensionError(actual, expected, relation) {\n  if (!(this instanceof DimensionError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.actual   = actual;\n  this.expected = expected;\n  this.relation = relation;\n\n  this.message = 'Dimension mismatch (' +\n      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +\n      ' ' + (this.relation || '!=') + ' ' +\n      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +\n      ')';\n\n  this.stack = (new Error()).stack;\n}\n\nDimensionError.prototype = new RangeError();\nDimensionError.prototype.constructor = RangeError;\nDimensionError.prototype.name = 'DimensionError';\nDimensionError.prototype.isDimensionError = true;\n\nmodule.exports = DimensionError;\n","'use strict';\n\nvar escape_latex = require('escape-latex')\n\nexports.symbols = {\n  // GREEK LETTERS\n  Alpha: 'A',     alpha: '\\\\alpha',\n  Beta: 'B',      beta: '\\\\beta',\n  Gamma: '\\\\Gamma',    gamma: '\\\\gamma',\n  Delta: '\\\\Delta',    delta: '\\\\delta',\n  Epsilon: 'E',   epsilon: '\\\\epsilon',  varepsilon: '\\\\varepsilon',\n  Zeta: 'Z',      zeta: '\\\\zeta',\n  Eta: 'H',       eta: '\\\\eta',\n  Theta: '\\\\Theta',    theta: '\\\\theta',    vartheta: '\\\\vartheta',\n  Iota: 'I',      iota: '\\\\iota',\n  Kappa: 'K',     kappa: '\\\\kappa',    varkappa: '\\\\varkappa',\n  Lambda: '\\\\Lambda',   lambda: '\\\\lambda',\n  Mu: 'M',        mu: '\\\\mu',\n  Nu: 'N',        nu: '\\\\nu',\n  Xi: '\\\\Xi',       xi: '\\\\xi',\n  Omicron: 'O',   omicron: 'o',\n  Pi: '\\\\Pi',       pi: '\\\\pi',       varpi: '\\\\varpi',\n  Rho: 'P',       rho: '\\\\rho',      varrho: '\\\\varrho',\n  Sigma: '\\\\Sigma',    sigma: '\\\\sigma',    varsigma: '\\\\varsigma',\n  Tau: 'T',       tau: '\\\\tau',\n  Upsilon: '\\\\Upsilon',  upsilon: '\\\\upsilon',\n  Phi: '\\\\Phi',      phi: '\\\\phi',      varphi: '\\\\varphi',\n  Chi: 'X',       chi: '\\\\chi',\n  Psi: '\\\\Psi',      psi: '\\\\psi',\n  Omega: '\\\\Omega',    omega: '\\\\omega',\n  //logic\n  'true': '\\\\mathrm{True}',\n  'false': '\\\\mathrm{False}',\n  //other\n  i: 'i', //TODO use \\i ??\n  inf: '\\\\infty',\n  Inf: '\\\\infty',\n  infinity: '\\\\infty',\n  Infinity: '\\\\infty',\n  oo: '\\\\infty',\n  lim: '\\\\lim',\n  'undefined': '\\\\mathbf{?}'\n};\n\nexports.operators = {\n  'transpose': '^\\\\top',\n  'factorial': '!',\n  'pow': '^',\n  'dotPow': '.^\\\\wedge', //TODO find ideal solution\n  'unaryPlus': '+',\n  'unaryMinus': '-',\n  'bitNot': '~', //TODO find ideal solution\n  'not': '\\\\neg',\n  'multiply': '\\\\cdot',\n  'divide': '\\\\frac', //TODO how to handle that properly?\n  'dotMultiply': '.\\\\cdot', //TODO find ideal solution\n  'dotDivide': '.:', //TODO find ideal solution\n  'mod': '\\\\mod',\n  'add': '+',\n  'subtract': '-',\n  'to': '\\\\rightarrow',\n  'leftShift': '<<',\n  'rightArithShift': '>>',\n  'rightLogShift': '>>>',\n  'equal': '=',\n  'unequal': '\\\\neq',\n  'smaller': '<',\n  'larger': '>',\n  'smallerEq': '\\\\leq',\n  'largerEq': '\\\\geq',\n  'bitAnd': '\\\\&',\n  'bitXor': '\\\\underline{|}',\n  'bitOr': '|',\n  'and': '\\\\wedge',\n  'xor': '\\\\veebar',\n  'or': '\\\\vee'\n};\n\nexports.defaultTemplate = '\\\\mathrm{${name}}\\\\left(${args}\\\\right)';\n\nvar units = {\n  deg: '^\\\\circ'\n};\n\nexports.escape = function (string) {\n  return escape_latex(string, {'preserveFormatting': true});\n}\n\n//@param {string} name\n//@param {boolean} isUnit\nexports.toSymbol = function (name, isUnit) {\n  isUnit = typeof isUnit === 'undefined' ? false : isUnit;\n  if (isUnit) {\n    if (units.hasOwnProperty(name)) {\n      return units[name];\n    }\n\n    return '\\\\mathrm{' + exports.escape(name) + '}';\n  }\n\n  if (exports.symbols.hasOwnProperty(name)) {\n    return exports.symbols[name];\n  }\n\n  return exports.escape(name);\n};\n","'use strict';\n\nvar clone = require('../../utils/object').clone;\nvar validateIndex = require('../../utils/array').validateIndex;\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\nvar setSafeProperty = require('../../utils/customs').setSafeProperty;\nvar DimensionError = require('../../error/DimensionError');\n\nfunction factory (type, config, load, typed) {\n  var matrix = load(require('../../type/matrix/function/matrix'));\n\n  /**\n   * Get or set a subset of a matrix or string.\n   *\n   * Syntax:\n   *     math.subset(value, index)                                // retrieve a subset\n   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset\n   *\n   * Examples:\n   *\n   *     // get a subset\n   *     var d = [[1, 2], [3, 4]];\n   *     math.subset(d, math.index(1, 0));        // returns 3\n   *     math.subset(d, math.index([0, 2], 1));   // returns [[2], [4]]\n   *\n   *     // replace a subset\n   *     var e = [];\n   *     var f = math.subset(e, math.index(0, [0, 2]), [5, 6]);  // f = [[5, 6]]\n   *     var g = math.subset(f, math.index(1, 1), 7, 0);         // g = [[5, 6], [0, 7]]\n   *\n   * See also:\n   *\n   *     size, resize, squeeze, index\n   *\n   * @param {Array | Matrix | string} matrix  An array, matrix, or string\n   * @param {Index} index                     An index containing ranges for each\n   *                                          dimension\n   * @param {*} [replacement]                 An array, matrix, or scalar.\n   *                                          If provided, the subset is replaced with replacement.\n   *                                          If not provided, the subset is returned\n   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when\n   *                                          the matrix is resized. If not provided,\n   *                                          math.matrix elements will be left undefined.\n   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.\n   */\n  var subset = typed('subset', {\n    // get subset\n    'Array, Index': function (value, index) {\n      var m = matrix(value);\n      var subset = m.subset(index);       // returns a Matrix\n      return index.isScalar()\n          ? subset\n          : subset.valueOf();  // return an Array (like the input)\n    },\n\n    'Matrix, Index': function (value, index) {\n      return value.subset(index);\n    },\n\n    'Object, Index': _getObjectProperty,\n\n    'string, Index': _getSubstring,\n\n    // set subset\n    'Array, Index, any': function (value, index, replacement) {\n      return matrix(clone(value))\n          .subset(index, replacement, undefined)\n          .valueOf();\n    },\n\n    'Array, Index, any, any': function (value, index, replacement, defaultValue) {\n      return matrix(clone(value))\n          .subset(index, replacement, defaultValue)\n          .valueOf();\n    },\n\n    'Matrix, Index, any': function (value, index, replacement) {\n      return value.clone().subset(index, replacement);\n    },\n\n    'Matrix, Index, any, any': function (value, index, replacement, defaultValue) {\n      return value.clone().subset(index, replacement, defaultValue);\n    },\n\n    'string, Index, string': _setSubstring,\n    'string, Index, string, string': _setSubstring,\n    'Object, Index, any': _setObjectProperty\n  });\n\n  subset.toTex = undefined; // use default template\n\n  return subset;\n\n  /**\n   * Retrieve a subset of a string\n   * @param {string} str            string from which to get a substring\n   * @param {Index} index           An index containing ranges for each dimension\n   * @returns {string} substring\n   * @private\n   */\n  function _getSubstring(str, index) {\n    if (!type.isIndex(index)) {\n      // TODO: better error message\n      throw new TypeError('Index expected');\n    }\n    if (index.size().length != 1) {\n      throw new DimensionError(index.size().length, 1);\n    }\n\n    // validate whether the range is out of range\n    var strLen = str.length;\n    validateIndex(index.min()[0], strLen);\n    validateIndex(index.max()[0], strLen);\n\n    var range = index.dimension(0);\n\n    var substr = '';\n    range.forEach(function (v) {\n      substr += str.charAt(v);\n    });\n\n    return substr;\n  }\n\n  /**\n   * Replace a substring in a string\n   * @param {string} str            string to be replaced\n   * @param {Index} index           An index containing ranges for each dimension\n   * @param {string} replacement    Replacement string\n   * @param {string} [defaultValue] Default value to be uses when resizing\n   *                                the string. is ' ' by default\n   * @returns {string} result\n   * @private\n   */\n  function _setSubstring(str, index, replacement, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      // TODO: better error message\n      throw new TypeError('Index expected');\n    }\n    if (index.size().length != 1) {\n      throw new DimensionError(index.size().length, 1);\n    }\n    if (defaultValue !== undefined) {\n      if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {\n        throw new TypeError('Single character expected as defaultValue');\n      }\n    }\n    else {\n      defaultValue = ' ';\n    }\n\n    var range = index.dimension(0);\n    var len = range.size()[0];\n\n    if (len != replacement.length) {\n      throw new DimensionError(range.size()[0], replacement.length);\n    }\n\n    // validate whether the range is out of range\n    var strLen = str.length;\n    validateIndex(index.min()[0]);\n    validateIndex(index.max()[0]);\n\n    // copy the string into an array with characters\n    var chars = [];\n    for (var i = 0; i < strLen; i++) {\n      chars[i] = str.charAt(i);\n    }\n\n    range.forEach(function (v, i) {\n      chars[v] = replacement.charAt(i[0]);\n    });\n\n    // initialize undefined characters with a space\n    if (chars.length > strLen) {\n      for (i = strLen - 1, len = chars.length; i < len; i++) {\n        if (!chars[i]) {\n          chars[i] = defaultValue;\n        }\n      }\n    }\n\n    return chars.join('');\n  }\n}\n\n/**\n * Retrieve a property from an object\n * @param {Object} object\n * @param {Index} index\n * @return {*} Returns the value of the property\n * @private\n */\nfunction _getObjectProperty (object, index) {\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1);\n  }\n\n  var key = index.dimension(0);\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property');\n  }\n\n  return getSafeProperty(object, key);\n}\n\n/**\n * Set a property on an object\n * @param {Object} object\n * @param {Index} index\n * @param {*} replacement\n * @return {*} Returns the updated object\n * @private\n */\nfunction _setObjectProperty (object, index, replacement) {\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1);\n  }\n\n  var key = index.dimension(0);\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property');\n  }\n\n  // clone the object, and apply the property to the clone\n  var updated = clone(object);\n  setSafeProperty(updated, key, replacement);\n\n  return updated;\n}\n\nexports.name = 'subset';\nexports.factory = factory;\n","'use strict';\n\nvar number = require('./number');\nvar string = require('./string');\nvar object = require('./object');\nvar types = require('./types');\n\nvar DimensionError = require('../error/DimensionError');\nvar IndexError = require('../error/IndexError');\n\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\nexports.size = function (x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n};\n\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len != size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n      _validate(array[i], size, dimNext);\n    }\n  }\n  else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\nexports.validate = function(array, size) {\n  var isScalar = (size.length == 0);\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  }\n  else {\n    // array\n    _validate(array, size, 0);\n  }\n};\n\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\nexports.validateIndex = function(index, length) {\n  if (!number.isNumber(index) || !number.isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n  if (index < 0 || (typeof length === 'number' && index >= length)) {\n    throw new IndexError(index, length);\n  }\n};\n\n// a constant used to specify an undefined defaultValue\nexports.UNINITIALIZED = {};\n\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. To leave new entries undefined,\n *                              specify array.UNINITIALIZED as defaultValue\n * @return {Array} array         The resized array\n */\nexports.resize = function(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  }\n\n  // check whether size contains positive integers\n  size.forEach(function (value) {\n    if (!number.isNumber(value) || !number.isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' +\n          '(size: ' + string.format(size) + ')');\n    }\n  });\n\n  // recursively resize the array\n  var _defaultValue = (defaultValue !== undefined) ? defaultValue : 0;\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n};\n\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\nfunction _resize (array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen);\n\n  // apply new length\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1;\n\n    // resize existing child arrays\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n        array[i] = elem;\n      }\n      _resize(elem, size, dimNext, defaultValue);\n    }\n\n    // create new child arrays\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem;\n\n      // resize new child array\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  }\n  else {\n    // last dimension\n\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    }\n\n    if(defaultValue !== exports.UNINITIALIZED) {\n      // fill new elements with the default value\n      for (i = minLen; i < newLen; i++) {\n        array[i] = defaultValue;\n      }\n    }\n  }\n}\n\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\nexports.reshape = function(array, sizes) {\n  var flatArray = exports.flatten(array);\n  var newArray;\n\n  var product = function (arr) {\n    return arr.reduce(function (prev, curr) {\n      return prev * curr;\n    });\n  };\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, product(exports.size(array)), '!=');\n  }\n\n  try {\n    newArray  = _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(\n        product(sizes),\n        product(exports.size(array)),\n        '!='\n      );\n    }\n    throw e;\n  }\n\n  if (flatArray.length > 0) {\n    throw new DimensionError(\n      product(sizes),\n      product(exports.size(array)),\n      '!='\n    );\n  }\n\n  return newArray;\n};\n\n/**\n * Recursively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\nfunction _reshape(array, sizes) {\n  var accumulator = [];\n  var i;\n\n  if (sizes.length === 0) {\n    if (array.length === 0) {\n      throw new DimensionError(null, null, '!=');\n    }\n    return array.shift();\n  }\n  for (i = 0; i < sizes[0]; i += 1) {\n    accumulator.push(_reshape(array, sizes.slice(1)));\n  }\n  return accumulator;\n}\n\n\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\nexports.squeeze = function(array, size) {\n  var s = size || exports.size(array);\n\n  // squeeze outer dimensions\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  }\n\n  // find the first dimension to be squeezed\n  var dims = s.length;\n  while (s[dims - 1] === 1) {\n    dims--;\n  }\n\n  // squeeze inner dimensions\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n};\n\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\nfunction _squeeze (array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  }\n  else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n * \n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n * \n * @param {Array} array\n * @param {number} dims     Desired number of dimensions of the array\n * @param {number} [outer]  Number of outer dimensions to be added\n * @param {Array} [size]    Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\nexports.unsqueeze = function(array, dims, outer, size) {\n  var s = size || exports.size(array);\n\n  // unsqueeze outer dimensions\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  }\n\n  // unsqueeze inner dimensions\n  array = _unsqueeze(array, dims, 0);\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n};\n\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\nfunction _unsqueeze (array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  }\n  else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\nexports.flatten = function(array) {\n  if (!Array.isArray(array)) {\n    //if not an array, return as is\n    return array;\n  }\n  var flat = [];\n\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback);  //traverse through sub-arrays recursively\n    }\n    else {\n      flat.push(value);\n    }\n  });\n\n  return flat;\n};\n\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\nexports.map = function (array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\nexports.forEach = function (array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\nexports.filter = function (array, callback) {\n  if (exports.size(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\nexports.filterRegExp = function (array, regexp) {\n  if (exports.size(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\nexports.join = function (array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array}\ta  An array\n * @return {Array}\tAn array of objects containing the original value and its identifier\n */\nexports.identify = function(a) {\n  if (!Array.isArray(a)) {\n\tthrow new TypeError('Array input expected');\n  }\n\t\n  if (a.length === 0) {\n\treturn a;\n  }\n\t\n  var b = [];\n  var count = 0;\n  b[0] = {value: a[0], identifier: 0};\n  for (var i=1; i<a.length; i++) {\n    if (a[i] === a[i-1]) {\n  \tcount++;\n    }\n    else {\n      count = 0;\n    }\n    b.push({value: a[i], identifier: count});\n  }\n  return b;\n}\n\n/**\n * Remove the numeric identifier from the elements\n * @param\ta  An array\n * @return\tAn array of values without identifiers\n */\nexports.generalize = function(a) {\n  if (!Array.isArray(a)) {\n\tthrow new TypeError('Array input expected');\n  }\n\t\n  if (a.length === 0) {\n\treturn a;\n  }\n\t\n  var b = [];\n  for (var i=0; i<a.length; i++) {\n    b.push(a[i].value);\n  }\n  return b;\n}\n\n/**\n * Test whether an object is an array\n * @param {*} value\n * @return {boolean} isArray\n */\nexports.isArray = Array.isArray;\n","'use strict';\n\nvar latex = require('../../utils/latex');\nvar operators = require('../operators');\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (!type.isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!type.isNode(trueExpr))  throw new TypeError('Parameter trueExpr must be a Node');\n    if (!type.isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n\n  ConditionalNode.prototype.type = 'ConditionalNode';\n\n  ConditionalNode.prototype.isConditionalNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {ConditionalNode} node  The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileConditionalNode(node, defs, args) {\n    if (!(node instanceof ConditionalNode)) {\n      throw new TypeError('No valid ConditionalNode')\n    }\n\n    /**\n     * Test whether a condition is met\n     * @param {*} condition\n     * @returns {boolean} true if condition is true or non-zero, else false\n     */\n    defs.testCondition = function (condition) {\n      if (typeof condition === 'number'\n          || typeof condition === 'boolean'\n          || typeof condition === 'string') {\n        return condition ? true : false;\n      }\n\n      if (condition) {\n        if (type.isBigNumber(condition)) {\n          return condition.isZero() ? false : true;\n        }\n\n        if (type.isComplex(condition)) {\n          return (condition.re || condition.im) ? true : false;\n        }\n\n        if (type.isUnit(condition)) {\n          return condition.value ? true : false;\n        }\n      }\n\n      if (condition === null || condition === undefined) {\n        return false;\n      }\n\n      throw new TypeError('Unsupported type of condition \"' + defs.math['typeof'](condition) + '\"');\n    };\n\n    return (\n      'testCondition(' + compile(node.condition, defs, args) + ') ? ' +\n      '( ' + compile(node.trueExpr, defs, args) + ') : ' +\n      '( ' + compile(node.falseExpr, defs, args) + ')'\n    );\n  }\n\n  // register the compile function\n  register(ConditionalNode.prototype.type, compileConditionalNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(\n        this._ifNode(callback(this.condition, 'condition', this)),\n        this._ifNode(callback(this.trueExpr, 'trueExpr', this)),\n        this._ifNode(callback(this.falseExpr, 'falseExpr', this))\n    );\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis);\n\n    //Enclose Arguments in parentheses if they are an OperatorNode\n    //or have lower or equal precedence\n    //NOTE: enclosing all OperatorNodes in parentheses is a decision\n    //purely based on aesthetics and readability\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);\n    if ((parenthesis === 'all')\n        || (this.condition.type === 'OperatorNode')\n        || ((conditionPrecedence !== null) && (conditionPrecedence <= precedence))) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);\n    if ((parenthesis === 'all')\n        || (this.trueExpr.type === 'OperatorNode')\n        || ((truePrecedence !== null) && (truePrecedence <= precedence))) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);\n    if ((parenthesis === 'all')\n        || (this.falseExpr.type === 'OperatorNode')\n        || ((falsePrecedence !== null) && (falsePrecedence <= precedence))) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis);\n\n    //Enclose Arguments in parentheses if they are an OperatorNode\n    //or have lower or equal precedence\n    //NOTE: enclosing all OperatorNodes in parentheses is a decision\n    //purely based on aesthetics and readability\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);\n    if ((parenthesis === 'all')\n        || (this.condition.type === 'OperatorNode')\n        || ((conditionPrecedence !== null) && (conditionPrecedence <= precedence))) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);\n    if ((parenthesis === 'all')\n        || (this.trueExpr.type === 'OperatorNode')\n        || ((truePrecedence !== null) && (truePrecedence <= precedence))) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);\n    if ((parenthesis === 'all')\n        || (this.falseExpr.type === 'OperatorNode')\n        || ((falsePrecedence !== null) && (falsePrecedence <= precedence))) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {'\n        + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;'\n        + this.condition.toTex(options)\n        + '}\\\\\\\\{' + this.falseExpr.toTex(options)\n        + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n\n  return ConditionalNode;\n}\n\nexports.name = 'ConditionalNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","var IndexError = require('../../error/IndexError');\n\n/**\n * Transform zero-based indices to one-based indices in errors\n * @param {Error} err\n * @returns {Error} Returns the transformed error\n */\nexports.transform = function (err) {\n  if (err && err.isIndexError) {\n    return new IndexError(\n        err.index + 1,\n        err.min + 1,\n        err.max !== undefined ? err.max + 1 : undefined);\n  }\n\n  return err;\n};\n","'use strict';\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * @constructor ParenthesisNode\n   * @extends {Node}\n   * A parenthesis node describes manual parenthesis from the user input\n   * @param {Node} content\n   * @extends {Node}\n   */\n  function ParenthesisNode(content) {\n    if (!(this instanceof ParenthesisNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    // validate input\n    if (!type.isNode(content)) {\n      throw new TypeError('Node expected for parameter \"content\"');\n    }\n\n    this.content = content;\n  }\n\n  ParenthesisNode.prototype = new Node();\n\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\n\n  ParenthesisNode.prototype.isParenthesisNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {ParenthesisNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileParenthesisNode(node, defs, args) {\n    if (!(node instanceof ParenthesisNode)) {\n      throw new TypeError('No valid ParenthesisNode')\n    }\n\n    return compile(node.content, defs, args);\n  }\n\n  // register the compile function\n  register(ParenthesisNode.prototype.type, compileParenthesisNode);\n\n  /**\n   * Get the content of the current Node.\n   * @return {Node} content\n   * @override\n   **/\n  ParenthesisNode.prototype.getContent = function () {\n    return this.content.getContent();\n  };\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  ParenthesisNode.prototype.forEach = function (callback) {\n    callback(this.content, 'content', this);\n  };\n\n  /**\n   * Create a new ParenthesisNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ParenthesisNode} Returns a clone of the node\n   */\n  ParenthesisNode.prototype.map = function (callback) {\n    var content = callback(this.content, 'content', this);\n    return new ParenthesisNode(content);\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ParenthesisNode}\n   */\n  ParenthesisNode.prototype.clone = function() {\n    return new ParenthesisNode(this.content);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ParenthesisNode.prototype._toString = function(options) {\n    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {\n      return '(' + this.content.toString(options) + ')';\n    }\n    return this.content.toString(options);\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ParenthesisNode.prototype.toHTML = function(options) {\n    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return this.content.toHTML(options);\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  ParenthesisNode.prototype._toTex = function(options) {\n    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {\n      return '\\\\left(' + this.content.toTex(options) + '\\\\right)';\n    }\n    return this.content.toTex(options);\n  };\n\n  return ParenthesisNode;\n}\n\nexports.name = 'ParenthesisNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\nvar getType = require('../../utils/types').type;\nvar stringify = require('../../utils/string').stringify;\nvar escape = require('../../utils/string').escape;\nvar escapeLatex = require('../../utils/latex').escape;\n\nfunction factory (type, config, load, typed) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * A ConstantNode holds a constant value like a number or string. A ConstantNode\n   * stores a stringified version of the value and uses this to compile to\n   * JavaScript.\n   *\n   * In case of a stringified number as input, this may be compiled to a BigNumber\n   * when the math instance is configured for BigNumbers.\n   *\n   * Usage:\n   *\n   *     // stringified values with type\n   *     new ConstantNode('2.3', 'number');\n   *     new ConstantNode('true', 'boolean');\n   *     new ConstantNode('hello', 'string');\n   *\n   *     // non-stringified values, type will be automatically detected\n   *     new ConstantNode(2.3);\n   *     new ConstantNode('hello');\n   *\n   * @param {string | number | boolean | null | undefined} value\n   *                            When valueType is provided, value must contain\n   *                            an uninterpreted string representing the value.\n   *                            When valueType is undefined, value can be a\n   *                            number, string, boolean, null, or undefined, and\n   *                            the type will be determined automatically.\n   * @param {string} [valueType]  The type of value. Choose from 'number', 'string',\n   *                              'boolean', 'undefined', 'null'\n   * @constructor ConstantNode\n   * @extends {Node}\n   */\n  function ConstantNode(value, valueType) {\n    if (!(this instanceof ConstantNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (valueType) {\n      if (typeof valueType !== 'string') {\n        throw new TypeError('String expected for parameter \"valueType\"');\n      }\n      if (typeof value !== 'string') {\n        throw new TypeError('String expected for parameter \"value\"');\n      }\n\n      this.value = value;\n      this.valueType = valueType;\n    }\n    else {\n      // stringify the value and determine the type\n      this.value = value + '';\n      this.valueType = getType(value);\n    }\n\n    if (!SUPPORTED_TYPES[this.valueType]) {\n      throw new TypeError('Unsupported type of value \"' + this.valueType + '\"');\n    }\n  }\n\n  var SUPPORTED_TYPES = {\n    'number': true,\n    'string': true,\n    'boolean': true,\n    'undefined': true,\n    'null': true\n  };\n\n  ConstantNode.prototype = new Node();\n\n  ConstantNode.prototype.type = 'ConstantNode';\n\n  ConstantNode.prototype.isConstantNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {ConstantNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileConstantNode(node, defs, args) {\n    if (!(node instanceof ConstantNode)) {\n      throw new TypeError('No valid ConstantNode')\n    }\n\n    switch (node.valueType) {\n      case 'number':\n        if (config.number === 'BigNumber') {\n          return 'math.bignumber(' + stringify(node.value) + ')';\n        }\n        else if (config.number === 'Fraction') {\n          return 'math.fraction(' + stringify(node.value) + ')';\n        }\n        else {\n          // remove leading zeros like '003.2' which are not allowed by JavaScript\n          validateNumericValue(node.value);\n          return node.value.replace(/^(0*)[0-9]/, function (match, zeros) {\n            return match.substring(zeros.length);\n          });\n        }\n\n      case 'string':\n        // Important to escape unescaped double quotes in the string\n        return stringify(node.value);\n\n      case 'boolean':\n        // prevent invalid values\n        return String(node.value) === 'true' ? 'true' : 'false';\n\n      case 'undefined':\n        return 'undefined';\n\n      case 'null':\n        return 'null';\n\n      default:\n        // TODO: move this error to the constructor?\n        throw new TypeError('Unsupported type of constant \"' + node.valueType + '\"');\n    }\n  }\n\n  /**\n   * Test whether value is a string containing a numeric value\n   * @param {String} value\n   * @return {boolean} Returns true when ok\n   */\n  function validateNumericValue (value) {\n    // The following regexp is relatively permissive\n    if (typeof value !== 'string' ||\n        !/^[\\-+]?((\\d+\\.?\\d*)|(\\d*\\.?\\d+))([eE][+\\-]?\\d+)?$/.test(value)) {\n      throw new Error('Invalid numeric value \"' + value + '\"');\n    }\n  }\n\n  // register the compile function\n  register(ConstantNode.prototype.type, compileConstantNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  ConstantNode.prototype.forEach = function (callback) {\n    // nothing to do, we don't have childs\n  };\n\n\n  /**\n   * Create a new ConstantNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ConstantNode} Returns a clone of the node\n   */\n  ConstantNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConstantNode}\n   */\n  ConstantNode.prototype.clone = function () {\n    return new ConstantNode(this.value, this.valueType);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ConstantNode.prototype._toString = function (options) {\n    switch (this.valueType) {\n      case 'string':\n        return stringify(this.value);\n\n      default:\n        return this.value;\n    }\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ConstantNode.prototype.toHTML = function (options) {\n\tvar value = escape(this.value);\n    switch (this.valueType) {\n\t  case 'number':\n\t    return '<span class=\"math-number\">' + value + '</span>';\n      case 'string':\n\t    return '<span class=\"math-string\">' + value + '</span>';\n      case 'boolean':\n\t    return '<span class=\"math-boolean\">' + value + '</span>';\n      case 'null':\n\t    return '<span class=\"math-null-symbol\">' + value + '</span>';\n      case 'undefined':\n\t    return '<span class=\"math-undefined\">' + value + '</span>';\n\n      default:\n        return '<span class=\"math-symbol\">' + value + '</span>';\n    }\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n  ConstantNode.prototype._toTex = function (options) {\n    var value = this.value,\n        index;\n    switch (this.valueType) {\n      case 'string':\n        return '\\\\mathtt{' + escapeLatex(stringify(value)) + '}';\n\n      case 'number':\n        index = value.toLowerCase().indexOf('e');\n        if (index !== -1) {\n          return value.substring(0, index) + '\\\\cdot10^{' +\n              value.substring(index + 1) + '}';\n        }\n        return value;\n\n      default:\n        return value;\n    }\n  };\n\n  return ConstantNode;\n}\n\nexports.name = 'ConstantNode';\nexports.path = 'expression.node';\nexports.factory = factory;\n","'use strict';\n\n// Reserved keywords not allowed to use in the parser\nmodule.exports = {\n  end: true\n};\n","'use strict';\n\nvar errorTransform = require('../../transform/error.transform').transform;\nvar setSafeProperty = require('../../../utils/customs').setSafeProperty;\n\nfunction factory (type, config, load, typed) {\n  var subset = load(require('../../../function/matrix/subset'));\n  var matrix = load(require('../../../type/matrix/function/matrix'));\n\n  /**\n   * Replace part of an object:\n   *\n   * - Assign a property to an object\n   * - Replace a part of a string\n   * - Replace a matrix subset\n   *\n   * @param {Object | Array | Matrix | string} object\n   * @param {Index} index\n   * @param {*} value\n   * @return {Object | Array | Matrix | string} Returns the original object\n   *                                            except in case of a string\n   */\n  // TODO: change assign to return the value instead of the object\n  return function assign(object, index, value) {\n    try {\n      if (Array.isArray(object)) {\n        return matrix(object).subset(index, value).valueOf();\n      }\n      else if (object && typeof object.subset === 'function') { // Matrix\n        return object.subset(index, value);\n      }\n      else if (typeof object === 'string') {\n        // TODO: move setStringSubset into a separate util file, use that\n        return subset(object, index, value);\n      }\n      else if (typeof object === 'object') {\n        if (!index.isObjectProperty()) {\n          throw TypeError('Cannot apply a numeric index as object property');\n        }\n        setSafeProperty(object, index.getObjectProperty(), value);\n        return object;\n      }\n      else {\n        throw new TypeError('Cannot apply index: unsupported type of object');\n      }\n    }\n    catch (err) {\n        throw errorTransform(err);\n    }\n  }\n}\n\nexports.factory = factory;\n","'use strict';\n\nvar latex = require('../../utils/latex');\nvar stringify = require('../../utils/string').stringify;\nvar escape = require('../../utils/string').escape;\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\nvar getSafeProperty = require('../../utils/customs').getSafeProperty;\n\nfunction factory (type, config, load, typed, math) {\n  var register = load(require('./compile')).register;\n  var compile = load(require('./compile')).compile;\n  var Node = load(require('./Node'));\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit (name) {\n    return type.Unit ? type.Unit.isValuelessUnit(name) : false;\n  }\n\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    // validate input\n    if (typeof name !== 'string')  throw new TypeError('String expected for parameter \"name\"');\n\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n\n  SymbolNode.prototype.type = 'SymbolNode';\n\n  SymbolNode.prototype.isSymbolNode = true;\n\n  /**\n   * Compile the node to javascript code\n   * @param {SymbolNode} node The node to be compiled\n   * @param {Object} defs     Object which can be used to define functions\n   *                          or constants globally available for the compiled\n   *                          expression\n   * @param {Object} args     Object with local function arguments, the key is\n   *                          the name of the argument, and the value is `true`.\n   *                          The object may not be mutated, but must be\n   *                          extended instead.\n   * @return {string} js\n   * @private\n   */\n  function compileSymbolNode(node, defs, args) {\n    if (!(node instanceof SymbolNode)) {\n      throw new TypeError('No valid SymbolNode')\n    }\n\n    // add a function to the definitions\n    defs['undef'] = undef;\n    defs['Unit'] = type.Unit;\n    defs.getSafeProperty = getSafeProperty;\n    defs.hasOwnProperty = hasOwnProperty;\n\n    var jsName = stringify(node.name); // escaped node name inside double quotes\n\n    if (hasOwnProperty(args, node.name)) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return args[node.name];\n    }\n    else if (node.name in defs.math) {\n      return '(' + jsName + ' in scope ' +\n          '? getSafeProperty(scope, ' + jsName + ') ' +\n          ': getSafeProperty(math, ' + jsName + '))';\n    }\n    else {\n      return '(' +\n          jsName + ' in scope ' +\n          '? getSafeProperty(scope, ' + jsName + ') ' +\n          ': ' + (isValuelessUnit(node.name)\n              ? 'new Unit(null, ' + jsName + ')'\n              : 'undef(' + jsName + ')') +\n          ')';\n    }\n  }\n\n  // register the compile function\n  register(SymbolNode.prototype.type, compileSymbolNode);\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  SymbolNode.prototype.forEach = function (callback) {\n    // nothing to do, we don't have childs\n  };\n\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n  function undef (name) {\n    throw new Error('Undefined symbol ' + name);\n  }\n\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n  SymbolNode.prototype.clone = function() {\n    return new SymbolNode(this.name);\n  };\n\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  SymbolNode.prototype._toString = function(options) {\n    return this.name;\n  };\n\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  SymbolNode.prototype.toHTML = function(options) {\n\tvar name = escape(this.name);\n\t\n    if (name == \"true\" || name == \"false\") {\n\t  return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n\t}\n\telse if (name == \"i\") {\n\t  return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n\t}\n\telse if (name == \"Infinity\") {\n\t  return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n\t}\n\telse if (name == \"NaN\") {\n\t  return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n\t}\n\telse if (name == \"null\") {\n\t  return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n\t}\n\telse if (name == \"uninitialized\") {\n\t  return '<span class=\"math-symbol math-uninitialized-symbol\">' + name + '</span>';\n\t}\n\t\n\treturn '<span class=\"math-symbol\">' + name + '</span>';\n  };\n\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n  SymbolNode.prototype._toTex = function(options) {\n    var isUnit = false;\n    if ((typeof math[this.name] === 'undefined') && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n    var symbol = latex.toSymbol(this.name, isUnit);\n    if (symbol[0] === '\\\\') {\n      //no space needed if the symbol starts with '\\'\n      return symbol;\n    }\n    //the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}\n\nexports.name = 'SymbolNode';\nexports.path = 'expression.node';\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\nexports.factory = factory;\n","'use strict';\n\nfunction factory(type, config, load, typed, math) {\n  var Node = math.expression.node.Node;\n  var OperatorNode = math.expression.node.OperatorNode;\n  var FunctionNode = math.expression.node.FunctionNode;\n  var ParenthesisNode = math.expression.node.ParenthesisNode;\n\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     simplify.resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.simplify.resolve('x + y', {x:1, y:2}) // Node {1 + 2}\n   *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}\n   *     math.simplify('x+y', {x:2, y:'x+x'}).toString(); // \"6\"\n   *\n   * @param {Node} node\n   *     The expression tree to be simplified\n   * @param {Object} scope with variables to be resolved\n   */\n  function resolve(node, scope) {\n    if (!scope) {\n        return node;\n    }\n    if (type.isSymbolNode(node)) {\n        var value = scope[node.name];\n        if (value instanceof Node) {\n            return resolve(value, scope);\n        } else if (typeof value === 'number') {\n            return math.parse(String(value));\n        }\n    } else if (type.isOperatorNode(node)) {\n        var args = node.args.map(function (arg) {\n          return resolve(arg, scope)\n        });\n        return new OperatorNode(node.op, node.fn, args);\n    } else if (type.isParenthesisNode(node)) {\n        return new ParenthesisNode(resolve(node.content, scope));\n    } else if (type.isFunctionNode(node)) {\n        var args = node.args.map(function (arg) {\n          return resolve(arg, scope)\n        });\n        return new FunctionNode(node.name, args);\n    }\n    return node;\n  }\n\n  return resolve;\n}\n\nexports.math = true;\nexports.name = 'resolve';\nexports.path = 'algebra.simplify';\nexports.factory = factory;\n","'use strict';\n\n/**\n * Create a range error with the message:\n *     'Index out of range (index < min)'\n *     'Index out of range (index < max)'\n *\n * @param {number} index     The actual index\n * @param {number} [min=0]   Minimum index (included)\n * @param {number} [max]     Maximum index (excluded)\n * @extends RangeError\n */\nfunction IndexError(index, min, max) {\n  if (!(this instanceof IndexError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.index = index;\n  if (arguments.length < 3) {\n    this.min = 0;\n    this.max = min;\n  }\n  else {\n    this.min = min;\n    this.max = max;\n  }\n\n  if (this.min !== undefined && this.index < this.min) {\n    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';\n  }\n  else if (this.max !== undefined && this.index >= this.max) {\n    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';\n  }\n  else {\n    this.message = 'Index out of range (' + this.index + ')';\n  }\n\n  this.stack = (new Error()).stack;\n}\n\nIndexError.prototype = new RangeError();\nIndexError.prototype.constructor = RangeError;\nIndexError.prototype.name = 'IndexError';\nIndexError.prototype.isIndexError = true;\n\nmodule.exports = IndexError;\n","'use strict';\n\nvar keywords = require('../keywords');\nvar deepEqual= require('../../utils/object').deepEqual;\nvar hasOwnProperty = require('../../utils/object').hasOwnProperty;\n\nfunction factory (type, config, load, typed, math) {\n  var compile = load(require('./compile')).compile;\n\n  /**\n   * Node\n   */\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n\n  /**\n   * Evaluate the node\n   * @param {Object} [scope]  Scope to read/write variables\n   * @return {*}              Returns the result\n   */\n  Node.prototype.eval = function(scope) {\n    return this.compile().eval(scope);\n  };\n\n  Node.prototype.type = 'Node';\n\n  Node.prototype.isNode = true;\n\n  Node.prototype.comment = '';\n\n  /**\n   * Compile the node to javascript code\n   * @return {{eval: function}} expr  Returns an object with a function 'eval',\n   *                                  which can be invoked as expr.eval([scope]),\n   *                                  where scope is an optional object with\n   *                                  variables.\n   */\n  Node.prototype.compile = function () {\n    // TODO: calling compile(math) is deprecated since version 2.0.0. Remove this warning some day\n    if (arguments.length > 0) {\n      throw new Error('Calling compile(math) is deprecated. Call the function as compile() instead.');\n    }\n\n    // definitions globally available inside the closure of the compiled expressions\n    var defs = {\n      math: math.expression.mathWithTransform,\n      args: {}, // can be filled with names of FunctionAssignment arguments\n      _validateScope: _validateScope\n    };\n\n    // will be used to put local function arguments\n    var args = {};\n\n    var code = compile(this, defs, args);\n\n    var defsCode = Object.keys(defs).map(function (name) {\n      return '    var ' + name + ' = defs[\"' + name + '\"];';\n    });\n\n    var factoryCode =\n        defsCode.join(' ') +\n        'return {' +\n        '  \"eval\": function (scope) {' +\n        '    if (scope) _validateScope(scope);' +\n        '    scope = scope || {};' +\n        '    return ' + code + ';' +\n        '  }' +\n        '};';\n\n    var factory = new Function('defs', factoryCode);\n    return factory(defs);\n  };\n\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n\n  /**\n   * Create a new Node having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n\n  /**\n   * Validate whether an object is a Node, for use with map\n   * @param {Node} node\n   * @returns {Node} Returns the input if it's a node, else throws an Error\n   * @protected\n   */\n  Node.prototype._ifNode = function (node) {\n    if (!type.isNode(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n\n    return node;\n  };\n\n  /**\n   * Recursively traverse all nodes in a node tree. Executes given callback for\n   * this node and each of its child nodes.\n   * @param {function(node: Node, path: string, parent: Node)} callback\n   *          A callback called for every node in the node tree.\n   */\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    callback(this, null, null);\n\n    // recursively traverse over all childs of a node\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n        _traverse(child, callback);\n      });\n    }\n\n    _traverse(this, callback);\n  };\n\n  /**\n   * Recursively transform a node tree via a transform function.\n   *\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\n   * ConstantNode with value 2:\n   *\n   *     var res = Node.transform(function (node, path, parent) {\n   *       if (node && node.isSymbolNode) && (node.name == 'x')) {\n   *         return new ConstantNode(2);\n   *       }\n   *       else {\n   *         return node;\n   *       }\n   *     });\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *          A mapping function accepting a node, and returning\n   *          a replacement for the node or the original node.\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\n   * @return {Node} Returns the original node or its replacement\n   */\n  Node.prototype.transform = function (callback) {\n    // traverse over all childs\n    function _transform (node, callback) {\n      return node.map(function(child, path, parent) {\n        var replacement = callback(child, path, parent);\n        return _transform(replacement, callback);\n      });\n    }\n\n    var replacement = callback(this, null, null);\n    return _transform(replacement, callback);\n  };\n\n  /**\n   * Find any node in the node tree matching given filter function. For example, to\n   * find all nodes of type SymbolNode having name 'x':\n   *\n   *     var results = Node.filter(function (node) {\n   *       return (node && node.isSymbolNode) && (node.name == 'x');\n   *     });\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *            A test function returning true when a node matches, and false\n   *            otherwise. Function signature:\n   *            callback(node: Node, index: string, parent: Node) : boolean\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\n   */\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n\n    return nodes;\n  };\n\n  // TODO: deprecated since version 1.1.0, remove this some day\n  Node.prototype.find = function () {\n    throw new Error('Function Node.find is deprecated. Use Node.filter instead.');\n  };\n\n  // TODO: deprecated since version 1.1.0, remove this some day\n  Node.prototype.match = function () {\n    throw new Error('Function Node.match is deprecated. See functions Node.filter, Node.transform, Node.traverse.');\n  };\n\n  /**\n   * Create a shallow clone of this node\n   * @return {Node}\n   */\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n\n  /**\n   * Create a deep clone of this node\n   * @return {Node}\n   */\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n\n  /**\n   * Deep compare this node with another node.\n   * @param {Node} other\n   * @return {boolean} Returns true when both nodes are of the same type and\n   *                   contain the same values (as do their childs)\n   */\n  Node.prototype.equals = function (other) {\n    return other\n        ? deepEqual(this, other)\n        : false\n  };\n\n  /**\n   * Get string representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n  Node.prototype.toString = function (options) {\n    var customString;\n    if (options && typeof options === 'object') {\n        switch (typeof options.handler) {\n          case 'object':\n          case 'undefined':\n            break;\n          case 'function':\n            customString = options.handler(this, options);\n            break;\n          default:\n            throw new TypeError('Object or function expected as callback');\n        }\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toString(options);\n  };\n\n  /**\n   * Get HTML representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\" or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n  Node.prototype.toHTML = function (options) {\n    var customString;\n    if (options && typeof options === 'object') {\n        switch (typeof options.handler) {\n          case 'object':\n          case 'undefined':\n            break;\n          case 'function':\n            customString = options.handler(this, options);\n            break;\n          default:\n            throw new TypeError('Object or function expected as callback');\n        }\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this.toHTML(options);\n  };\n\n  /**\n   * Internal function to generate the string output.\n   * This has to be implemented by every Node\n   *\n   * @throws {Error}\n   */\n  Node.prototype._toString = function () {\n    //must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n\n  /**\n   * Get LaTeX representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n  Node.prototype.toTex = function (options) {\n    var customTex;\n    if (options && typeof options == 'object') {\n      switch (typeof options.handler) {\n        case 'object':\n        case 'undefined':\n          break;\n        case 'function':\n          customTex = options.handler(this, options);\n          break;\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    }\n\n    return this._toTex(options);\n  };\n\n  /**\n   * Internal function to generate the LaTeX output.\n   * This has to be implemented by every Node\n   *\n   * @param {Object} [options]\n   * @throws {Error}\n   */\n  Node.prototype._toTex = function (options) {\n    //must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n\n  /**\n   * Get the content of the current Node.\n   * @return {Node} node\n   **/\n  Node.prototype.getContent = function () {\n    return this;\n  };\n\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n  function _validateScope(scope) {\n    for (var symbol in scope) {\n      if (hasOwnProperty(scope, symbol)) {\n        if (symbol in keywords) {\n          throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n        }\n      }\n    }\n  }\n\n  return Node;\n}\n\nexports.name = 'Node';\nexports.path = 'expression.node';\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\nexports.factory = factory;\n"],"sourceRoot":""}